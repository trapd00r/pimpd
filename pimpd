#!/usr/bin/perl
our $APP      = 'pimpd';
our $VERSION  = '1.7.0';

use strict;
my $DEBUG = 0;

use Audio::MPD;
use List::Util qw(shuffle);
use Pod::Usage;
use Getopt::Long;
use File::Copy;
use Carp;
use Pod::Usage;
use File::Path 'make_path';

if($DEBUG) {
  use Data::Dumper;
}

if(!@ARGV) {
  print "$APP $VERSION\n";
  pod2usage(verbose => 1);
  exit(0);
}

my $config = "$ENV{XDG_CONFIG_HOME}/pimpd/pimpd.conf";
if($DEBUG) {
  require "./pimpd.conf";
}
else {
  eval {require $config;};
  if($@) {
    $config = "/etc/pimpd.conf";
  }
  require($config);
}

# Imported from the config
our(
  $basedir,

  $playlist_dir,
  $favlist_db_dir,
  $favlist_db_global,
  $fallback_playlist,

  $portable,

  $remote_host,
  $remote_port,
  $remote_user,
  $remote_pass,

  $ssh_host,
  $ssh_port,
  $ssh_user,

  $history_playlist,

  $opt_color,
  @c,

  $daemon_cmd,

  $pidfile,

  $dzen_cmd,
  $dzen_font,
);

file_exists();

# Used for GetOptions()
our(
  @opt_queue,
  $opt_shell,
  @opt_list_external,
  $opt_information,

  $opt_search_artist,
  $opt_search_album,
  $opt_search_title,
  $opt_search_playlist,
  $opt_search_db,
  $opt_search_all_playlists,

  $opt_randomize,
  $opt_random_track_in_playlist,

  @opt_add_playlist,
  $opt_playlist,
  $opt_write_favlist,
  $opt_parse_favlist,
  $opt_play_from_list,

  $opt_monitor,
  $opt_monitor_d,

  $opt_list_albums,
  $opt_list_songs_on_album,

  $opt_current,

  $opt_run_cp,
  $opt_cp_list,
  $opt_cp_album,

  $opt_add_current_album,

  $opt_clear_playlist,

  # So we could override configured settings on the commandline
  $opt_remote_host,
  $opt_remote_port,
  $opt_remote_pass,
);

my(undef, undef, undef, undef, $month, $year) = localtime(time);
$month += 1;
$year  += 1900;


my $e = "\e[38;5";

my $mpd;
if(defined($remote_host)) {
  $mpd = Audio::MPD->new(
    host      => $remote_host,
    port      => $remote_port,
    pass      => $remote_pass,
  );
}
else {
  $mpd = Audio::MPD->new;
}

GetOptions(
  'information'        => \$opt_information,
  'np'                 => \$opt_current,
  'r|randomize:i'      => \$opt_randomize,
  'rt|random-track'    => \$opt_random_track_in_playlist,
  'cp|copy'            => \$opt_run_cp,
  'cpl|cp-list:s{1,}'  => sub { shift; cp_list(shift); },
  'cpa|cp-album'       => \$opt_cp_album,
  'f|favorite'         => \$opt_write_favlist,
  'fs|favstats:s'      => sub { shift; favlist_stats(shift); },
  'l|listalbums'       => \$opt_list_albums,
  'lsa|listsongs:i'    => sub
  {
    shift;
    $opt_list_songs_on_album = shift;
    if(!defined($opt_list_songs_on_album) or $opt_list_songs_on_album == 0) {
      # fulhack
      $opt_list_songs_on_album = 'nothing to add';
    }
  },
  'aa|add-album'       => \$opt_add_current_album,
  'p|playlist'         => \$opt_playlist,
  'track|play'         => \$opt_play_from_list,
  'add=s{1,}'          => \@opt_add_playlist,
  'lp|lsp|list-pl'     => sub
  {
    print "$_\n" for sort($mpd->collection->all_playlists);
    exit(0);
  },
  'm|mon|monitor'      => \$opt_monitor,
  'md|monitord'        => \$opt_monitor_d,
  'queue=i{1,}'        => \@opt_queue,
  'shell'              => \$opt_shell,
  'external=s{1,}'     => \@opt_list_external,
  'spl|search-pl=s'    => \$opt_search_playlist,
  'sdb|search-db=s'    => \$opt_search_db,
  'sal|search-album=s' => \$opt_search_album,
  'sar|search-artist=s'=> \$opt_search_artist,
  'set|search-title=s' => \$opt_search_title,
  'sap|favsearch=s'    => \$opt_search_all_playlists,

  'no-color|nocolor'   => \$opt_color,
  'c|clear'            => \$opt_clear_playlist,
  'host:s'             => \$opt_remote_host,
  'port:s'             => \$opt_remote_port,
  'pass:s'             => \$opt_remote_pass,
  'ssh_host:s'         => \$ssh_host,
  'ssh_port:s'         => \$ssh_port,
  'ssh_user:s'         => \$ssh_user,

  'kill'               => \&killkid,
  'mpd-kill'           => sub { $mpd->kill; },
  'debug'              => \$DEBUG,
  'h|help'             => \&help,
  'man'                => sub { pod2usage(verbose => 3) },
);

# ... we need to recreate the MPD object
if($opt_remote_host) {
  $opt_remote_port = ($opt_remote_port) ? ($opt_remote_port) : ($remote_port);
  $opt_remote_pass = ($opt_remote_pass) ? ($opt_remote_pass) : ($remote_pass);
  $mpd = Audio::MPD->new(
    host  => $opt_remote_host,
    port  => $opt_remote_port,
    pass  => 'void',
  );
}

@c = () if($opt_color); # No colors

cp() if($opt_run_cp);

do {
  my $i = 0;
  for(@c) {
    printf("$c[$i]\$c[$i]\e[0m\n");
    $i++;
  }
} if($DEBUG);

sub shell_msg_help {
  printf("%s %s\n%s
    $APP $VERSION
    OPTIONS:
        rand      n    randomize a new playlist with n tracks
        play      n    play track n in playlist
        add       s    add playlist s
        aa        NIL  add the full album of the currently playing song
        sdb       p    search the database for pattern
        sar       p    search for artists matching pattern
        sal       p    search for albums matching pattern
        set       p    search for titles matching pattern
        spl       p    search the playlist for pattern
        fav       NIL  add the current track to the favorites
        favstats  NIL  generate statistics from all favlists
        list      NIL  show the current playlist
        lsa       (n)  list all songs on the current album
        i         NIL  show now playing information
        np        NIL  show the currently playing track
        cp        NIL  copy the currently playing track to specifed location
        cpl       s    copy the content of playlist s to specifed location
        rt        NIL  play a random track from the playlist
        n         NIL  next track
        p         NIL  previous track
        s         NIL  shuffle the playlist
        ra        NIL  toggle random on/off
        re        NIL  toggle repeat on/off
        cl        NIL  clear the current playlist
        cr        NIL  crop the current track
        q         n    queue n tracks
        l         NIL  list all albums featuring artist
        e         s    list all tracks in playlist s

        h         NIL  show this help

        exit      NIL  exit


        \n", shift,
      );
}

if($mpd->status->playlistlength < 1) {

  do {
    shell();
  }
    unless($opt_randomize
      or $opt_search_db
      or $opt_search_album
      or $opt_search_artist
      or $opt_search_title
      or @opt_add_playlist
      or $opt_shell
      or $opt_current
      or @opt_list_external
      or $opt_cp_list
  );
}

if($mpd->status->state eq 'stop') {
  $mpd->play;
}

print current(), "\n"                         if $opt_current;
information()                                 if $opt_information;
playlist()                                    if $opt_playlist;
write_favlist(shift)                          if $opt_write_favlist;
parse_favlist(generate_fav_struct())          if $opt_parse_favlist;
list_albums()                                 if $opt_list_albums;
list_songs_on_album($opt_list_songs_on_album) if $opt_list_songs_on_album;
play_from_list()                              if $opt_play_from_list;
monitor()                                     if $opt_monitor;

if($opt_monitor_d) {
  if(!defined($daemon_cmd)) {
    print STDERR "No daemon command specified in $config\n" and exit(1);
  }
  if(-e $pidfile) {
    print STDERR "pimpd is already running\n" and exit(1);
  }
  else {
    monitor();
  }
}
randomize($opt_randomize)                       if $opt_randomize;
random_track_in_playlist()                      if $opt_random_track_in_playlist;
add_playlist(0, @opt_add_playlist)              if @opt_add_playlist;
add_current_album()                             if $opt_add_current_album;
queue(@opt_queue)                               if @opt_queue;
shell()                                         if $opt_shell;
list_external(@opt_list_external)               if @opt_list_external;
search_playlist($opt_search_playlist)           if $opt_search_playlist;

search_db($opt_search_db)                       if $opt_search_db;
search_album($opt_search_album)                 if $opt_search_album;
search_artist($opt_search_artist)               if $opt_search_artist;
search_title($opt_search_title)                 if $opt_search_title;
search_all_playlists($opt_search_all_playlists) if $opt_search_all_playlists;
cp_list($opt_cp_list)                           if $opt_cp_list;
cp_album()                                      if $opt_cp_album;

sub information {
  my %current = ('artist'     =>  $mpd->current->artist,
                 'album'      =>  $mpd->current->album,
                 'title'      =>  $mpd->current->title,
                 'genre'      =>  $mpd->current->genre,
                 'file'       =>  $mpd->current->file,
                 'date'       =>  $mpd->current->date,
                 'time'       =>  $mpd->status->time->sofar.'/'.
                                  $mpd->status->time->total,
                 'bitrate'    =>  $mpd->status->bitrate,
                 'audio'      =>  $mpd->status->audio,
                 );
  my %status  = ('repeat'     =>  $mpd->status->repeat,
                 'shuffle'    =>  $mpd->status->random,
                 'xfade'      =>  $mpd->status->xfade,
                 'volume'     =>  $mpd->status->volume,
                 'state'      =>  $mpd->status->state,
                 'list'       =>  $mpd->status->playlist,
                 );
  my %stats   = ('song'       =>  $mpd->status->song,
                 'length'     =>  $mpd->status->playlistlength,
                 'songs'      =>  $mpd->stats->songs,
                 'albums'     =>  $mpd->stats->albums,
                 'artists'    =>  $mpd->stats->artists,
                 );

  $current{'bitrate'} = ($current{'bitrate'} < 192)
    ? ("$e;160m$current{'bitrate'}\e[0m")
    : ("$e;70m$current{'bitrate'}\e[0m")
    ;

  for(keys(%current)) {
    $current{$_} = "$e;240mNot Available$e;0m" if(!defined($current{$_}));
  }

  $status{state} = 'Playing' if($status{state} eq 'play');
  $status{state} = 'Paused'  if($status{state} eq 'pause');
  $status{state} = 'Stopped' if($status{state} eq 'stop');

  (undef,undef,undef,undef,undef, my $crnt_year) = localtime(time);
  $crnt_year += 1900;

  $current{date} = "$e;38m$c[15]$current{date}\e[0m" if($current{date} eq $crnt_year);

  $status{repeat}  = onoff($status{repeat});
  $status{shuffle} = onoff($status{repeat});

  if($status{volume} < 0) {
    $status{volume} = 'N/A (Software Mixer)';
  }

  printf("$e;251m$c[15]S\e[0m%10s$c[6]$c[15] %.66s\e[0m \n",
    'Artist:', $current{artist});

  printf("$e;250mO\e[0m%10s$c[8] %.66s\e[0m \n",
    'Album:' , $current{album});

  printf("$e;249mN\e[0m%10s$c[7]$c[15] %.66s \n",
    'Song:'  , $current{title});

  printf("$e;248mG\e[0m%10s %.66s \n",
    'Genre:' , $current{genre});

  printf(" %10s$c[9] $c[15]%.66s\e[0m \n",
    'File:'  , $current{file});

  printf("$e;247m$c[15]I\e[0m%10s %.66s \n",
    'Year:'  , $current{date});

  printf("$e;246mN\e[0m%10s %.66s \n",
    'Time:'  , $current{time});

  printf("$e;245mF\e[0m%10s %.66s \n",
    'Bitrate:'  , $current{bitrate});

  printf("$e;244mO\e[0m%10s %.66s \n",
    'Audio:' , $current{audio});

  print "$c[13]$c[15]";
  print '-' x 25, "\e[0m\n";

  printf("$e;243m$c[15]S\e[0m%10s %.66s \n",
    'Repeat:', $status{repeat});

  printf("$e;242mT\e[0m%10s %.66s \n",
    'Shuffle:',$status{shuffle});

  printf("$e;241mA\e[0m%10s %.66s \n", 'Xfade:', $status{xfade});
  printf("$e;240mT\e[0m%10s %.66s \n", 'Volume:', $status{volume});
  printf("$e;239mU\e[0m%10s %.66s \n", 'State:', $status{state});
  printf("$e;238mS\e[0m%10s %.66s \n", 'List V:', $status{list});

  print "$c[13]$c[15]";
  print '-' x 25, "$c[15]\n";

  printf("$e;243m$c[15]S\e[0m%10s %.66s \n", 'Song:', $stats{song});
  printf("$e;236mT\e[0m%10s %.66s \n", 'List:', $stats{length} . ' songs');
  printf("$e;235mA\e[0m%10s %.66s \n", 'Songs:', $stats{songs});
  printf("$e;234mT\e[0m%10s %.66s \n", 'Albums:', $stats{albums});
  printf("$e;234mS\e[0m%10s %.66s \n", 'Artists:', $stats{artists});

}

sub randomize {
  my $count = shift // 100;
  my @songs = shuffle($mpd->collection->all_pathes);

  $mpd->playlist->clear if($opt_clear_playlist);
  $mpd->playlist->add(@songs[0 .. $count-1]);
  $mpd->random(1);
  $mpd->repeat(1);
  $mpd->play;

  playlist("Added $count random songs:\n\n");
}

sub random_track_in_playlist {
  if(playlist_is_empty()) {
    print STDERR "Playlist is empty - nothing to play\n";
    return 1;
  }
  my @items = $mpd->playlist->as_items;
  if(!@items) {
    print "uh, uh...\n";
    return 1;
  }
  @items = shuffle(@items);
  $mpd->play($items[0]->pos);
  print current('show') . "\n";
}

sub playlist {
  my $header = shift;
  $header = "Playlist:\n" if($header eq 'show');

  my @playlist = $mpd->playlist->as_items;

  print $header;

  my $i = 0;
  for my $song(@playlist) {
    my $title  = $song->title  // 'undef';
    my $artist = $song->artist // 'undef';

    $i++;

    my $w = "$c[15]$c[6]";
    if($i % 2 == 0) {
      $w = "$c[8]\e[0m";
    }

    my $crnt_title  = $mpd->current->title // undef;
    my $crnt_artist = $mpd->current->artist // undef;
    $title       =~ s/(\w+)/\u\L$1/g;
    $artist      =~ s/(\w+)/\u\L$1/g;
    $crnt_title  =~ s/(\w+)/\u\L$1/g;
    $crnt_artist =~ s/(\w+)/\u\L$1/g;

    if($mpd->current->pos == ($i - 1)) {
      $w = "$c[15]$c[4]";
      printf("$w%4d\e[0m $w$c[4]%25.25s$c[8]▕$w$c[4]·$c[8]▏$w$c[4]%-47.47s\e[0m\n",
        $i, $artist, $title);
    }
    else {
      printf("$w%4d\e[0m $w$c[13]%25.25s$c[8]▕$w$c[14]|$c[8]▏$w$c[11]%-47.47s\e[0m\n",
        $i, $artist, $title);
    }
  }
  print "\n" . current('show'), "\n";
}

sub search_all_playlists {
  my $query = shift;

  if(!defined($query) or $query eq '') {
    print STDERR "No query specified\n";
    return 1;
  }
  if(invalid_re($query)) {
    print STDERR "$query is not valid regex. See 'perldoc perlretut'\n";
    return 1;
  }

  my @matched_files;

  open(my $fh, '<', $favlist_db_global) or die($!);
  while(<$fh>) {
    if($_ =~ /$query/i) {
      my ($artist, $album, $title, $genre, $file)
        = $_ =~ /"(.+)", "(.+)", "(.+)", "(.+)", "(.+)"/;

      printf("$c[15]%25.25s\e[0m $c[3]%-47.47s\e[0m\n", $artist, $title);

      # Fulhack. The absolute path might be needed for other applications and
      # that's the reason why the basedir is here in the first place
      # MPD doesnt like it though.
      $file =~ s;$basedir/;;;
      push(@matched_files, $file);
    }
  }
  close($fh);
  $mpd->playlist->add(@matched_files);
  return 0;
}

sub add_playlist {
  my $clear_or_not = shift; # clear playlist?
  if(@_) {
    if( ($_[0] eq 'all') and (not('all' ~~ $mpd->collection->all_playlists)) ) {

      print "Adding all playlists\n";
      my @all = $mpd->collection->all_playlists;
      $mpd->playlist->clear if($opt_clear_playlist);
      for(@all) {
        $mpd->playlist->load($_);
      }
      return 0;
    }

    my @playlists = @_;
    @playlists = is_existing_list(@playlists);

    return 1 if(!@playlists);

    $mpd->playlist->clear if($opt_clear_playlist);

    $mpd->playlist->load(@playlists);
    print "Adding ";
    print "$c[15]$_\e[0m " for @playlists;
    print "\n";

    $mpd->play;
  }
}

sub list_external {
  my @playlists = @_;

  @playlists = is_existing_list(@playlists);
  for my $playlist(@playlists) {
    my $full_path = "$playlist_dir/$playlist\.m3u";

    my $fh = undef;
    if(defined($remote_host)) {
      #$full_path =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
      open($fh, "ssh -p $ssh_port $ssh_user\@$ssh_host \"/bin/cat '$full_path'\"|")
        or die("$ssh_host:$ssh_port: $!");
    }
    else {
      open($fh, '<', $full_path) or die("Can not open $full_path: $!");
    }
    while(<$fh>) {
      print "$c[4]$playlist\e[0m: $c[15]$_\e[0m";
    }
    close($fh);
  }
  return 0;
}

sub scp {
  my($host, $port, $src, $dest) = @_;

  $src  =~ s/([ '"&;|])/\\$1/g;
  $dest =~ s/([ '"&;|])/\\$1/g;
  system('scp', '-r',  "-P $port", "$host:$src", $dest) == 0 or croak("scp: $!");
  return 0;
}

sub cp {
  my $dest = shift // $portable;

  is_existing_dir($dest);

  chomp(my $file = $mpd->current->file);

  # escape evil chars the shell will munch
  #$file =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;

  if(defined($remote_host)) {
    return scp($ssh_host, $ssh_port, "$basedir/$file", $dest)
  }

  if(copy("$basedir/$file", $dest)) {
    my($basename) = $file =~ m;.+/(.+)$;;
    printf("$c[4]$c[15]%s\e[0m$c[15] => \e[0m$c[6]%s\e[0m\n",
      $basename, $dest);
  }
  else {
    print STDERR "cp: $basedir/$file $!\n";
  }
  return 0;
}

sub is_existing_dir {
  my $dir = shift;

  if(-e $dir && ! -d $dir) {
    print STDERR "$dir exists, but is not a directory\n";
    print STDERR "Delete and mkdir $dir?\n";

    chomp(my $choice = <STDIN>);

    if(lc($choice ne 'y')) {
      print STDERR "Bailing out\n";
      return 1;
    }
    else {
      if(unlink($dir)) {
        print "$dir removed successfully\n";
      }
      else {
        print STDERR "Could not remove $dir: $!\n";
        return 1;
      }
    }
  }
  elsif(! -d $dir) {
    if(make_path($dir, 1, 0777)) {
      print "$c[5]>>\e[0m$c[15] $dir\e[0m created\n\n";
    }
    else {
      print STDERR "Could not mkdir $dir: $!\n";
    }
  }
}

sub cp_album {
  my $dest = shift // $portable;

  is_existing_dir($dest);

  if(! -d $dest) {
    if(make_path("$dest", 1, 0777)) {
      print "$dest $c[15]created\e[0m";
    }
    else {
      print STDERR "Could not create $dest: $!\n";
      return 1;
    }
  }

  my $file  = $mpd->current->file;
  return 1 if(!$file);

  my $path  = "$basedir/$file";
  my($basename) = $path  =~ m;.+/(.+)$;;
  my($album)    = $path  =~ m;(.+)/.+$;;
  my($albname)  = $album =~ m;.+/(.+)$;;

  $basename =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
  $album    =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;

  do {
    print "PATH: $path\n";
    print "BASENAME: $basename\n";
    print "ALBUM: $album\n";
    print "ALBNAME: $albname\n";
  } if($DEBUG);

  printf("$c[13]$c[15]%50.50s\e[0m$c[15] => \e[0m$c[3]%s\e[0m\n",
    $albname, $dest);


  if(defined($remote_host)) {
    my @files = grep{ /\.(?:mp3|ogg|flac|wav)$/ } `ssh -p $ssh_port $ssh_user\@$ssh_host 'find "$album"'`;
    for(@files) {
      chomp;
      $_ =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
    }

    open(OLD_STDOUT, '>&', STDOUT) or die($!);
    close(STDOUT);

    for(@files) {
      my ($basename) = $_ =~ m;.+/(.+)$;;
      if(scp($ssh_host, $ssh_port, $_, $dest) == 0) {
        # Yes, we are abusing STDERR here. Sorry :)
        printf STDERR ("%50.50s\n", $basename);
      }
      else {
        print STDERR "$!\n";
      }
    }
    open(STDOUT, '>&', OLD_STDOUT) or die($!);
  }
  else {
    for(grep{ /\.(?:mp3|ogg|flac|wav)$/ } glob("$album/*")) {
      my ($basename) = $_ =~ m;.+/(.+)$;;
      if(copy($_, $dest)) {
        printf("%50.50s\n", $basename);
      }
      else {
        print STDERR "$_: $!\n";
        return 1;
      }
    }
  }
  return 0;
}

sub is_existing_list {
  my @lists       = @_;
  my @valid_lists = sort($mpd->collection->all_playlists);

  for my $list(@lists) {
    if($list ~~ @valid_lists) {
      next;
    }
    else {
      my @choices = ();

      for my $valid(@valid_lists) {
        if($valid =~ /$list/i) {
          push(@choices, $valid);
        }
      }
      if(scalar(@choices) == 0) {
        print STDERR "No such playlist '$c[5]$list\e[0m'\n";
        return;
      }

      my $i = 0;
      for my $choice(@choices) {
        printf("$c[15]%3d\e[0m %s\n", $i, $choice);
        $i++;
      }
      print "choice: ";
      chomp(my $answer = <STDIN>);


      if($answer ~~ @valid_lists) {
        $list = $answer;
      }
      # Make sure the number selected is in fact valid
      elsif($answer >= 0 and $answer <= scalar(@valid_lists)) {
        $list = $choices[$answer];
      }
      else {
        print STDERR "$answer is not valid\n";
        return 1;
      }
    }
  }
  return(@lists);
}


sub cp_list {
  my @lists = @_;
  my $dest  = $portable;

  is_existing_dir($dest);
  @lists = is_existing_list(@lists);

  my %playlist_map;

  for my $playlist(@lists) {
    my $full_path = "$playlist_dir/$playlist\.m3u";

    my $fh = undef;

    if(defined($remote_host)) {
      open($fh, "ssh -p $ssh_port $ssh_user\@$ssh_host \"/bin/cat '$full_path'\"|")
        or die("cp_list(): $ssh_host:$ssh_port: $!");
    }
    else {
      open($fh, '<', $full_path) or die("Can not open $full_path: $!");
    }

    while(<$fh>) {
      chomp;
      $playlist_map{$_} = $playlist;
    }
    close($fh);
  }

  for my $file(keys(%playlist_map)) {
    my $full = "$basedir/$file";

    if(defined($remote_host)) {
      $full =~ s/([ä;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
      scp($ssh_host, $ssh_port, "$full", $dest);
    }
    else {
      my($basename) = $file =~ m;.+/(.+)$;;
      if(copy($full, $dest)) {
        printf("[$c[6]%5.11s\e[0m] %50.50s $c[15] => \e[0m %s\n",
          $playlist_map{$file}, $basename, $dest);
      }
      else {
        print STDERR "cp_list(): $!\n";
        return 1;
      }
    }
  }
  return 0;
}

sub file_exists {
  my $rc = undef;
  if(defined($remote_host)) {
    system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
       'test', '-d', $ENV{XDG_DATA_HOME}
     );
    $rc = $?;

    if($rc == 1) { # XDG_DATA_HOME is defined
      $rc = undef;
      system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
        'test', '-d', "$ENV{XDG_DATA_HOME}/pimpd"
      );
      $rc = $?;
      if($rc == 0) { # the pimpd dir doesnt exist
        system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
          'mkdir', '-p', "$ENV{XDG_DATA_HOME}/pimpd"
        );
        $favlist_db_dir = `ssh -p $ssh_port $ssh_user\@$ssh_host \"printf $ENV{XDG_DATA_HOME}/pimpd\"`;
      }
    }
    else {
      system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
        'mkdir', '-p', "$ENV{HOME}/.local/share/pimpd"
      );
      $favlist_db_dir = `ssh -p $ssh_port $ssh_user\@$ssh_host \"printf $ENV{HOME}/.local/share/pimpd\"`;
    }
  }
  elsif(defined($ENV{XDG_DATA_HOME})) {
    if(! -d "$ENV{XDG_DATA_HOME}/pimpd") {
      make_path("$ENV{XDG_DATA_HOME}/pimpd", 1, 0777);
    }
    $favlist_db_dir = "$ENV{XDG_DATA_HOME}/pimpd/";
  }
  else {
    if(! -d "$ENV{HOME}/.local/share/pimpd") {
      make_path("$ENV{HOME}/.local/share/pimpd", 1, 0777);
    }
    $favlist_db_dir = "$ENV{HOME}/.local/share/pimpd";
  }

  if(!-e $favlist_db_global) {
    open(my $fh, '>', $favlist_db_global) or warn($!);
    close($fh);
  }
}

sub write_favlist {
  my $artist = $mpd->current->artist // 'undef';
  my $album  = $mpd->current->album  // 'undef';
  my $title  = $mpd->current->title  // 'undef';
  my $genre  = $mpd->current->genre  // 'undef';
  my $file   = $basedir . '/' . $mpd->current->file;

  my(undef, undef, undef, undef, $month, $year) = localtime(time);
  $month += 1;
  $year  += 1900;

  my $favlist_db_monthly  = $favlist_db_dir
    . sprintf("%d-%02d.favlist", $year, $month);

  my $favlist_m3u = $playlist_dir . "/"
    . sprintf("%d-%02d_%s.m3u", $year, $month, $genre);


  my $fh = undef;

  if(defined($remote_host)) {
    # 'Illegal seek'... why? It seems to work anyway, so dont die here, for now
    # Regular m3u
    system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
      "echo '$file' >> $favlist_m3u"
      );
    printf("$c[3]%s\e[0m\e[1m >> \e[0m %s\n", $file, "\e[1m$ssh_host\e[0m:$favlist_m3u");

    # Full DB
    my $full_str = sprintf("\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"",
      $artist, $album, $title, $genre, $file
    );
    system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
      "echo '$full_str' >> $favlist_db_global"
    );

    # Monthly
    system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
      "echo '$full_str' >> $favlist_db_monthly"
    );
    return 0;
  }

  # Monthly
  open(my $fh, '>>', $favlist_db_monthly) or die($!);
  print $fh "\"$artist\", \"$album\", \"$title\", \"$genre\", \"$file\"\n";
  close($fh);

  # Full DB
  open(my $fh, '>>', $favlist_db_global) or die($!);
  print $fh "\"$artist\", \"$album\", \"$title\", \"$genre\", \"$file\"\n";
  close($fh);

  # Regular m3u
  open(my $fh, '>>', $favlist_m3u) or die($!);
  print $fh "$file\n";
  close($fh);

  print "$c[8]$c[15]'$title'\e[0m => $c[6]$favlist_m3u\e[0m\n";

  return 0;
}

sub generate_fav_struct {
  my(undef, undef, undef, undef, $month, $year) = localtime(time);
  $month += 1;
  $year  += 1900;

  my $favlist_db  = $favlist_db_dir
    . sprintf("%d-%02d.favlist", $year, $month);

  my %fav_struct = ();
  my $fh = undef;

  if(defined($remote_host)) {
    open($fh, "ssh -p $ssh_port $ssh_user\@$ssh_host \"/bin/cat '$favlist_db_global'\"|")
      or die($!);
  }
  else {
    open($fh, '<', $favlist_db) or die("$favlist_db: $!");
  }
  while(<$fh>) {
    chomp;

    my($artist, $album, $title, $genre, $file) = split(/,/, $_);

    $artist =~ s/"(.+)"/$1/;
    $album  =~ s/"(.+)"/$1/;
    $title  =~ s/"(.+)"/$1/;
    $genre  =~ s/"(.+)"/$1/;
    $file   =~ s/"(.+)"/$1/;

    push(@{$fav_struct{$artist}{$album}{$title}{$genre}}, $file)
      unless($file ~~ @{$fav_struct{$artist}{$album}{$title}{$genre}});
  }
  return(\%fav_struct);
}

sub parse_favlist {
  my $fav    = shift;
  my($tag, $query) = @_; # album 'Best of';

  my $i = 0;
  for my $artist(keys(%{$fav})) {
    for my $album(keys(%{$fav->{$artist}})) {
      for my $title(keys(%{$fav->{$artist}{$album}})) {
        for my $genre(keys(%{$fav->{$artist}{$album}{$title}})) {
          print "\e[1m\e[38;5;65m$album\e[0m:\n";
          for my $song_on_album(sort(@{$fav->{$artist}{$album}{$title}{$genre}})) {

            my($albname) = $song_on_album =~ m;.+/(.+)$;;

            if($albname =~ /($query)(.*)/gpi) {
              $albname = "${^PREMATCH}$c[5]$c[15]$1\e[0m$2";
            }
            printf("% 2d\t%s\n", $i, $title);
            $i++;
          }
        }
      }
    }
  }
}

sub favlist_stats {
  my $display_all = shift;

  my(undef, undef, undef, undef, $month, $year) = localtime(time);
  $month += 1;
  $year  += 1900;
  my $favlist_db  = $favlist_db_dir
    . sprintf("%d-%02d.favlist", $year, $month);

  my(%artists, %albums, %titles, %genres, %files);

  my $fh = undef;

  if(defined($remote_host)) {
    open($fh, "ssh -p $ssh_port $ssh_user\@$ssh_host \"/bin/cat '$favlist_db_global'\"|")
      or die($!);
  }
  else {
    open($fh, '<', $favlist_db_global) or die("$favlist_db: $!");
  }

  while(<$fh>) {

    my($artist, $album, $title, $genre, $file) = undef;

    $_  =~ m/"(.+)", "(.+)", "(.+)", "(.+)", "(.+)"/;

    # We have to do the checks backwards
    $file  = (defined($5)) ? $5 : 'undef';
    $genre = (defined($4)) ? $4 : 'undef';
    $title = (defined($3)) ? $3 : 'undef';
    $album = (defined($2)) ? $2 : 'undef';
    $artist= (defined($1)) ? $1 : 'undef';


    #my($artist, $album, $title, $genre, $file) = split(/,/, $_);

    # We're not interested in favs with missing tags
    $artists{$artist}++ unless($artist eq 'undef');
    $albums{$album}++   unless($album  eq 'undef');
    $titles{$title}++   unless($title  eq 'undef');
    $genres{$genre}++   unless($genre  eq 'undef');
    $files{$file}++;
  }

  printf("$c[0]$c[15]%20s\e[0m  $c[15]$c[6]%s\e[0m\n", 'Count', 'Artist') unless(!$display_all);
  for(sort { $artists{$b} <=> $artists{$a} } keys(%artists)) {
    if($display_all) {
      printf("$c[15]%20d\e[0m  %s\n", $artists{$_}, $_);
    }
    else {
      printf("%s $c[15]%s\e[0m %s $c[6]$c[15]%s\e[0m %s $c[2]$c[15]%d\e[0m %s\n",
        'Your favorite', 'artist', 'are', $_, 'with', $artists{$_},
        'loved songs');
      last;
    }
  }
  printf("$c[15]$c[6]%27s\e[0m\n", 'Album') unless(!$display_all);
  for(sort { $albums{$b} <=> $albums{$a} } keys(%albums)) {
    if($display_all) {
      printf("$c[15]%20d\e[0m  %s\n", $albums{$_}, $_);
    }
    else {
      printf("%s $c[15]%s\e[0m %s $c[6]$c[15]%s\e[0m %s $c[2]$c[15]%d\e[0m %s\n",
        'Your favorite', ' album', 'are', $_, 'with', $albums{$_},
        'loved songs');
      last;
    }
  }
  printf("$c[15]$c[6]%27s\e[0m\n", 'Genre') unless(!$display_all);
  for(sort { $genres{$b} <=> $genres{$a} } keys(%genres)) {
    if($display_all) {
      printf("$c[15]%20d\e[0m  %s\n", $genres{$_}, $_);
    }
    else {
      printf("%s $c[15]%s\e[0m %s $c[6]$c[15]%s\e[0m %s $c[2]$c[15]%d\e[0m %s\n",
        'Your favorite', ' genre', 'are', $_, 'with', $genres{$_},
        'loved songs');
      last;
    }
  }
}

sub list_albums {
  my $artist = $ARGV[0] // $mpd->current->artist;
  my @albums = sort($mpd->collection->albums_by_artist($artist));

  for(sort(@albums)) {
    print "$_\n";
  }
  printf("\n$c[0]$c[15]%s\e[0m is featured on $c[15]%d\e[0m albums\n",
    $artist, scalar(@albums),
  );
}

sub list_songs_on_album {
  my $num = shift;

  #FIXME Add 'all' tracks on album

  my $album = $mpd->current->album;
  if(!defined($album) or $album eq '') {
    print STDERR "Album tag missing!\n";
    return 1;
  }
  my @tracks = $mpd->collection->songs_from_album($album);

  if(defined($num) and $num ne 'nothing to add') {
    if($num > scalar(@tracks)) {
      print STDERR "There are "
        . scalar(@tracks)
        . " songs on \e[1m$c[1]$album\e[0m\n";
      return 1;
    }
    my $file = $tracks[$num]->file;
    $mpd->playlist->add($file);
    printf("\e[1mAdded\e[0m $c[1]%s\e[0m - %s\n",
      $tracks[$num]->artist, $tracks[$num]->title,
    );
    return 0;
  }

  my $i = 0;
  printf("$c[4]$c[15] %50.50s\e[0m\n", $album);

  for(@tracks) {
    printf("% 3s %50.50s %s\n", $i, $_->title, sec_and_min($_->time));
    $i++;
  }
  return 0;
}

sub add_current_album {
  my $album = $mpd->current->album;

  if(!defined($album) or $album eq '') {
    print STDERR "No album tag\n";
    return 1;
  }

  my @tracks = $mpd->collection->songs_from_album($album);

  $mpd->playlist->clear if($opt_clear_playlist);
  for(@tracks) {
    printf("%s\n", $_->title);
    $mpd->playlist->add($_->file);
  }

}

sub sec_and_min {
  my $sec = shift;
  my($s, $m) = localtime($sec);

  return sprintf("$c[6]$c[15]%d\e[0m$c[6]m\e[0m$c[6]$c[15]% 2d\e[0m$c[6]s\e[0m",
    $m, $s);
}

sub play_from_list {
  my $choice = $ARGV[0] // shift;
  if(!$choice) {
    print STDERR "What should we play?\n";
    exit(1);
  }

  if($choice !~ /^\d+$/) {
    print STDERR "Integers only, please.\n";
  }
  if($choice > $mpd->status->playlistlength) {
    print STDERR "There are $c[15]" . $mpd->status->playlistlength
      . "\e[0m songs in the playlist. Pick one of them!\n";
      return 1;
  }
  $mpd->play($choice-1);
  print current(), "\n";
}

sub daemonize {
  my $daemon_log = shift // '/dev/null';
  use POSIX 'setsid';
  my $PID = fork();
  exit(0) if($PID); #parent
  exit(1) if(!defined($PID)); # out of resources

  setsid();
  $PID = fork();
  exit(1) if(!defined($PID));

  if($PID) { # parent
    waitpid($PID, 0);
    unlink($pidfile); # remove the lock when child have died
    exit(0);
  }
  elsif($PID == 0) { # child
    open(my $fh, '>', $pidfile) or die("Cant open $pidfile: $!");
    print $fh $$;
    close($fh);
    open(STDOUT, '>', $daemon_log);
    open(STDERR, '>', '/dev/null');
    open(STDIN,  '<', '/dev/null');
  }
}

sub killkid {
  open(my $fh, '<', $pidfile) or print "pimpd is not running\n" and exit(1);
  my $target = <$fh>;
  close($fh);

  if(kill(9, $target)) {
    print "pimpd with PID $target terminated\n";
  }
  else {
    print "Could not kill $target: $!";
  }
  exit(0);
}

sub monitor {
  my $np = "";
  unless($DEBUG) {
    daemonize if($opt_monitor_d);
  }

  while(1) {
    my $current = $mpd->current;
    return 1 if(!defined($current)); # not running?
    my $output;
    if($opt_monitor_d) {
      my $artist = $mpd->current->artist // 'undef';
      my $album  = $mpd->current->album  // 'undef';
      my $title  = $mpd->current->title  // 'undef';
      my $genre  = $mpd->current->genre  // 'undef';
      my $year   = $mpd->current->date   // 0;

      if($daemon_cmd eq 'dzen') {
        $output = sprintf(
          "^fg(#4af617)%s ^fg(#999999)by^fg() ^fg(#fa4b04)%s^fg(#999999)",
            $title, $artist
            . sprintf(" (^fg(#fa0443) %s^fg(#999999) ) ", $album)
            . sprintf("^fg(#999999)from ^fg(#1c79ed)%s^fg()", $year)
          );
      }
      else {
        $output = sprintf("%s (%s) %s | %s", $artist, $album, $title, $genre);
      }
    }

    if("$np" ne "$current") {
      $np = $current;

      if($opt_monitor_d) {
        if($daemon_cmd eq 'dzen') {
          system("echo \"$output\" | $dzen_cmd");
        }
        else {
          system("$daemon_cmd \"$output\"");
        }
      }
      else {
        my @date = localtime(time);
        my @rc = shuffle(@c);
        my $file = $mpd->current->file;
        printf("%02s:%02s:%02s | $rc[0]%.68s$c[9]\n",
          $date[2], $date[1], $date[0], $file);
      }
    }
    sleep 2;
  }
}

sub queue {
  my @to_play = @_;
  if(scalar(@to_play < 1)) {
    print STDERR "The queue function requires at least one song \n";
    return 1;
  }
  for(@to_play) {
    if(invalid_pos($_)) {
      print STDERR "$c[5]$_\e[0m: invalid position\n";
      return 1;
    }
  }

  # The playlist numbering starts with 1
  # The internal numbering starts with 0
  @to_play = map { $_--} @to_play;

  my @track_in_list = $mpd->playlist->as_items;
  my $argc = 0;

  print ">> Starting queue...\n";
  while(scalar(@to_play) > $argc) {

    $mpd->play($to_play[$argc]);

    my $time = $mpd->status->time->seconds_total;
    $argc++;

    my $next_in_list = $to_play[$argc];
    print current() . "\n";

    printf("$c[13]>>> %s - %s - %s \e[0m\n",
      $track_in_list[$next_in_list]->artist,
      $track_in_list[$next_in_list]->album,
      $track_in_list[$next_in_list]->title,
    ) if(scalar(@to_play) != $argc);

    if(scalar(@to_play) == 1) {
      return 0;
    }
    sleep($time);
  }
  print ">> Queue finished.\n";
}

sub shell {
  my $option = shift;
  my($cmd, $arg, @cmd_args); # for later use
  shell_msg_help();

  my $opts = {
    'rand'    => sub {
      if(!defined($_[0])) {
        $_[0] = 100;
      }
      elsif(defined($_[0]) and $_[0] !~ /^\d+$/) {
        print STDERR "@_[0] is not a valid integer\n";
        $_[0] = 100;
      }
      print "Adding $c[15]@_\e[0m random tracks to the playlist...\n";
      randomize(@_);
    },


    'list'      => sub {
      if(playlist_is_empty()) {
        print STDERR "Playlist is empty\n";
        return 1;
      }
      playlist();
    },

    'fav'       => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      write_favlist(@_);
    },
    'favstats'  => sub {
      if($_[0] eq 'all') {
        favlist_stats(1);
      }
      else {
        favlist_stats(0);
      }
    },

    'play'      => sub {
      @_[0] = 1 if @_[0] !~ /^\d+$/;
      play_from_list(@_);
    },

    'cp'        => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      cp();
    },

    'cpa'       => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      cp_album();
    },

    'cpl'       => sub { cp_list(@_); },
    'i'         => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      information();
    },

    'mon'       => sub {
      if(playlist_is_empty()) {
        print STDERR "Playlist is empty - there's nothing to monitor\n";
        return 1;
      }
      monitor();
    },

    'sar'       => sub {
      my $artist = join(' ', @_);
      search_artist($artist);
    },

    'sal'       => sub {
      my $album = join(' ', @_);
      search_album($album);
    },

    'set'       => sub {
      my $title = join(' ', @_);
      search_title($title);
    },

    'sdb'       => sub {
      my $search = join(' ', @_);
      search_db($search);
    },

    'spl'       => sub {
      my $search = join(' ', @_);
      search_playlist($search);
    },

    'sap'       => sub {
      my $search = join(' ', @_);
      search_all_playlists($search);
    },

    'l'         => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      list_albums();
    },
    'lsa'       => sub { list_songs_on_album(@_); },

    'e'         => sub { list_external(@_); },
    'add'       => sub {
      add_playlist(0, @_); # Dont clear the current playlist
    },

    'n'         => sub {
      if(playlist_is_empty()) {
        print STDERR "Playlist is empty!\n";
        return 1;
      }
      $mpd->next;
      print current() . "\n";
    },

    'p'         => sub {
      if(playlist_is_empty()) {
        print STDERR "Playlist is empty!\n";
        return 1;
      }
      $mpd->prev;
      print current() . "\n";
    },

    't'         => sub {
      $mpd->pause;
      print $mpd->status->state . "\n";
    },

    's'         => sub {
      $mpd->playlist->shuffle;
      print "New playlist version is " .$mpd->status->playlist . "\n"
    },

    'np'        => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      print current() . "\n";
    },

    'q'         => sub {
      if(invalid_pos(@_)) {
        printf("No such song%s\n", (@_ < 1) ? 's' : '');
        return 1;
      }
      queue(@_);
    },

    'ra'        => sub {
      $mpd->random;
      my $status =  ($mpd->status->random)
        ? "Random: $c[15]On\e[0m"
        : "Random: $c[15]Off\e[0m";
      print "$status\n";
    },

    're'        => sub {
      $mpd->repeat;
      my $status = ($mpd->status->repeat)
        ? "Repeat: $c[15]On\e[0m"
        : "Repeat: $c[15]Off\e[0m";
      print "$status\n";
    },

    'rt'        => sub { random_track_in_playlist(); },
    'aa'        => sub { add_current_album(); },
    'cl'        => sub { $mpd->playlist->clear; },
    'cr'        => sub { $mpd->playlist->crop; },
    'h'         => sub { shell_msg_help(); },
    'exit'      => sub { exit(0); },
  };

  while(1) {
    print "$c[6]pimpd$c[15]>\e[0m$c[15]$c[0] ";
    chomp(my $choice = <STDIN>);
    print "\e[0m";
    ($cmd) = $choice =~ m/^(\w+)/;
    ($arg) = $choice =~ m/\s+(.+)$/;
    @cmd_args  = split(/\s+/, $arg);

    print "cmd: $cmd\narg: @cmd_args\n" if($DEBUG);

    if(defined($opts->{$cmd})) {
      $mpd->play;
      $opts->{$cmd}->(@cmd_args);
    }
    else {
      $opts->{h}->();
      print STDERR "$c[15]No such option $c[5]$cmd\e[0m\n";
    }
  }
  exit(0);
}

sub search_playlist {
  my $search   = shift;

  my %playlist = undef;

  for($mpd->playlist->as_items) {
    # http://sv.wikipedia.org/wiki/Fulhack
    $playlist{pos}->{$_->pos} = $_->artist . ' ' . $_->album . ' ' . $_->title;
  }

  my @found;

  if(invalid_re($search)) {
    print STDERR "'$search' is not valid regex. See 'perldoc perlretut'\n";
    return 1;
  }

  # NOTE Should we ignore dupes?
  # All Saints = Pure Shores <=> All Saints - Pure Shores
  # Or maybe compare by album as well. Crap could be live, remixes and what not,
  # even though the title doesnt say so.
  # Or maybe we should just let the user craft their regex good enough :)

  # 'pos'
  for my $pos(keys(%playlist)) {
    # 42
    for my $pos_no(keys(%{$playlist{$pos}})) { # 42
      # Laleh Me and Simon Big City Love
      if($playlist{$pos}{$pos_no} =~ /($search)(.*)/gpi) {
        push(@found, $pos_no);

        # GNU Grep like color-matching
        print "${^PREMATCH}$c[5]$c[15]$1\e[0m$2\n";
      }
    }
  }

  if(scalar(@found) < 1) {
    print STDERR "No match on '$c[15]$search\e[0m' in the current playlist\n";
    return 1;
  }
  queue(@found);
}

sub search_db {
  my $search = shift;

  if(invalid_re($search)) {
    print STDERR "'$search' is not valid regex. See 'perldoc perlretut'\n";
    return 1;
  }

  for($mpd->collection->all_pathes) {
    if($_ =~ /$search/i) {
      printf("> %.77s\n", $_);
      $mpd->playlist->add($_);
    }
  }
  $mpd->play;
}

sub search_album {
  my $search = shift;
  my @tracks = $mpd->collection->songs_from_album_partial($search);
  if(!@tracks) {
    print ">> $c[2]$search$c[9]: no tracks found\n";
    return 1;
  }
  @tracks = map { $_ = $_->file } @tracks;
  pipe_add(@tracks);

  printf(">> $c[6]$c[15]%d\e[0m $c[15]album\e[0m matches for '$c[10]$c[15]%s\e[0m' found\n",
    scalar(@tracks), $search);
}

sub search_artist {
  my $search = shift;
  my @artists = $mpd->collection->songs_by_artist_partial($search);
  if(!@artists) {
    print ">> $c[2]$search$c[9]: nothing found\n";
    return 1;
  }
  @artists = map { $_ = $_->file } @artists;
  pipe_add(@artists);

  printf(">> $c[6]$c[15]%d\e[0m $c[15]artist\e[0m matches for '$c[10]$c[15]%s\e[0m' found\n",
    scalar(@artists), $search);
}

sub search_title  {
  my $search = shift;
  my @songs = $mpd->collection->songs_with_title_partial($search);
  if(!@songs) {
    print ">> $c[2]$search$c[9]: nothing found\n";
    return 1;
  }
  @songs = map { $_ = $_->file } @songs;
  pipe_add(@songs);

  printf(">> $c[6]$c[15]%d\e[0m $c[15]song\e[0m matches for '$c[10]$c[15]%s\e[0m' found\n",
    scalar(@songs), $search);
}

sub pipe_add {
  return if(!@_);
  print "$_\n" for @_;
  $mpd->playlist->add(@_);
}

sub current {
  if(playlist_is_empty()) {
    print STDERR "Playlist is empty - nothing is playing\n";
    exit(1);
  }
  my $cu = $mpd->current;
  my(
    $artist,
    $song,
    $album,
    $bitrate,
    $genre,
    $pos,
  ) = (
    $cu->artist           // 'undef',
    $cu->title            // 'undef',
    $cu->album            // 'undef',
    $mpd->status->bitrate // 0,
    $cu->genre            // 'No genre',
    $cu->pos + 1,
  );

  my $current = undef;

  $bitrate = ($bitrate < 160)
  ? ("$c[5]$bitrate\e[0m")
  : ("$c[13]$bitrate\e[0m");

  if(!defined($artist) or(!defined($song))) {
    if(terminal_output()) {
      $current = sprintf("[$c[15]$c[8]%d\e[0m]$c[1]>>$c[9] %s$c[15]%s\e[0m",
        $pos, "$basedir/", $cu->file);
    }
    else {
      $current = sprintf(" >> %s %s",
        "$basedir/", $cu->file);
    }
  }
  else {
    if(terminal_output()) {
      $current = sprintf("[$c[15]$c[8]%d\e[0m]$c[3]>>$c[9] $c[1]$c[15]%s\e[0m - $c[15]$c[3]%s\e[0m ",
        $pos, $artist, $song)
        . sprintf("from $c[15]$c[4]%s\e[0m ($bitrate kbps) [$genre]", $album);
    }
    else {
      $current = sprintf(" [%d]>> %s - %s from %s [%s]",
        $pos, $artist, $song, $album, $genre
      );
    }
  }
  return($current);
}

sub terminal_output {
  if(-t *STDOUT) {
    return 1;
  }
  else {
    @c = (); # make sure no escape sequences escape through
    return 0;
  }
}

sub playlist_is_empty {
  if($mpd->playlist->as_items == 0) {
    return 1;
  }
  else {
    return 0;
  }
}

sub invalid_pos {
  my @pos = @_;
  my @playlist = map { $_ = $_->pos } $mpd->playlist->as_items;
  my $fail = 0;

  for(@pos) {
    if($_ ~~ @playlist) {
      # all good
    }
    else {
      $fail++;
    }
  }
  return($fail);
}

sub invalid_re {
  my $re = shift;
  eval { qr/$re/ };
  if($@) {
    return 1;
  }
  else {
    return 0;
  }
}

sub onoff {
  my $what = shift;
  $what = ($what) ? 'Yes' : 'No';
  return($what);
}

sub help {
  print "$APP $VERSION\n";
  pod2usage(verbose => 1);
  exit(0);
}


=pod

=head1 NAME

  pimpd - Perl Interface for the Music Player Daemon

=head1 SYNOPSIS

  pimpd [OPTIONS...] (ARG)

=head1 DESCRIPTION

pimpd is an MPD client written in Perl that aims to implement what the
excellent mpc client is lacking (for good reasons), as well as all the
regular functionality one would expect.

=head3 Regular expression based queries

  You can search the database and playlist using regular expressions. There are
  several other (faster) ways to search as well - by artist, album or title.

  Additionally, it's possible to search through all favlists at the same time,
  adding the matches to the current playlist. Since pimpd internally keeps an
  csv-style database up to date with the favorized tracks, it's enough to search
  for artist, album, title, genre and/or file, in any combination.

=head3 Randomizing

  -r will create a new playlist with <num> randomly selected tracks from the
     database added.

  -rt will play a random track from the current playlist.

=head3 Favorites

  Favorites are handled in several ways. When the -f flag is used, pimpd will
  check for the genre tag of the song and, if existing, save it in the playlist
  directory with a year-month_genre-notation.
  If there's no genre tag, the $fallback_playlist, specified in the
  configuration file, is used.

  pimpd will also keep a CSV-style database updated with more additional data on
  the song. This have several purposes:

  * other applications might expect regular m3u-style playlists with only a
    defined "file"-field,

  * the database holds additional information on the favorites, which allows for
    more powerful search capabilities, and

  * we can generate nifty stats for loved songs

=head3 Transfering of music

  There are several ways of transfering music.

  This is especially useful if the MPD server is running elsewhere and you want
  to listen to the music locally, or if you want to transfer some music to your
  portable music player.

  The $ssh_host, $ssh_port and $ssh_user variables in the configuration file
  must be defined in the configuration file, and you must be using SSH keys for
  this to work over networks.

  -cp  simply copies the currently playing track to the specifed location.

  -cpa copies the full album where the currently playing track is featured.

  -cpl copies all tracks in the specified playlist to the specified location.

=head3 Interactive shell

  From the interactive shell one can access almost all functionality that's
  available through regular option flags.

=head3 Monitor song changes

  There are two ways to monitor song changes:

  -m  simply print song changes to stdout.

  -md monitor in daemon mode. This is useful for things like OSD notifications,
      integration in dzen2 and so on. Most window managers uses their own sort
      of notification functionality which can also be used.

=head3 Now playing

  There are two options that will yeild some info on the current track:

  -i   print all information available.

  -np  print information on the currently playing track only, on a single line.

=head3 Colors

  pimpd does support colorschemes, which are defined and loaded from the
  configuration file. 256 colors is supported, as well as no colors at all.

  All of this works on local MPD servers as well as remote ones.

=head1 OPTIONS

  -i,     --info          show all info for the currently playing song
  -np,    --current       print basic song info on a single line
  -r,     --random        randomize a new playlist with <num> tracks
  -rt,    --random-track  play a random track from the playlist
  -cp,    --copy          copy the current track to specified location
  -cpa,   --cp-album      copy the current album to specified location
  -cpl,   --cp-list       copy playlist <str> to specified location
  -f,     --fav           add the current track to the favorites
  -fs,    --favstats      generate statistics based on previous favorizations
  -l,     --listalbums    list all albums featuring artist
  -lsa,   --listsongs     list all songs on the current album
  -lsp,   --list-pl       list all available playlists
  -p,     --playlist      show the current playlist
  -t,     --track         play track <num> from playlist
  -a,     --add           add playlist <str>. If <str> eq "all", add all
  -aa,    --add-album     add the current album to the playlist
  -m,     --monitor       monitor MPD for song changes (output on STDOUT)
  -md,    --monitor-d     monitor MPD for song changes in daemon mode
  -k,     --kill          kill pimpd when running in daemon mode
  -q,     --queue         queue <num> tracks
  -e,     --external      list all tracks in external playlist
  -sh,    --shell         spawn the interactive pimpd shell
  -spl,   --search-pl     search the playlist for [<pattern>]
  -sdb,   --search-db     search the database for [<pattern>]
  -sar,   --search-artist search the database for [<artist>]
  -sal,   --search-album  search the database for [<album>]
  -set,   --search-title  search the database for [<title>]
  -sap,   --favsearch     search the favlists for artist, album, title, file
  -c,     --clear         clear the playlist before performing any action that
                          generates a new playlist
  -no,    --no-color      turn colors off
          --mpd-kill      shut down the MPD server
          --host          remote MPD host
          --port          remote MPD port
          --pass          remote MPD password
          --ssh-host      remote SSH server host
          --ssh-port      remote SSH server port
          --ssh-user      remote SSH server user

  -h,     --help          show the help and exit
          --man           show the manpage and exit

=head1 ENVIRONMENT

The configuration file should be placed in $XDG_CONFIG_HOME/pimpd/pimpd.conf OR
/etc/pimpd.conf

=head1 AUTHOR

Written by Magnus Woldrich

=head1 REPORTING BUGS

Report bugs and feature requests at the issue tracker
<http://github.com/trapd00r/pimpd/issues>

Girls can contact me at <trapd00r@trapd00r.se>

=head1 COPYRIGHT

Copyright (C) 2009, 2010 Magnus Woldrich

=head1 SEE ALSO

B<rmcd>  <http://github.com/trapd00r/rmcd>

=cut
