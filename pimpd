#!/usr/bin/perl
our $APP      = 'pimpd';
our $VERSION  = '1.8.6';

use strict;
my $DEBUG = 0;

use Audio::MPD;
use List::Util qw(shuffle);
use Pod::Usage;
use Getopt::Long;
use File::Copy;
use Carp;
use Pod::Usage;
use File::Path qw(make_path remove_tree);
use Term::ExtendedColor qw(fg clear);


if(!@ARGV) {
  print "$APP $VERSION\n";
  pod2usage(verbose => 1);
  exit(0);
}

my $config = "$ENV{XDG_CONFIG_HOME}/pimpd/pimpd.conf";
if($DEBUG) {
  require "./pimpd.conf";
}
else {
  eval {require $config;};
  if($@) {
    $config = "/etc/pimpd.conf";
  }
  require($config);
}

# Imported from the config
our(
  $basedir,

  $playlist_dir,
  $favlist_db_dir,
  $favlist_db_global,
  $fallback_playlist,

  $portable,

  $mpd_host,
  $mpd_port,
  $mpd_user,
  $mpd_pass,

  $ssh_host,
  $ssh_port,
  $ssh_user,

  $history_playlist,

  $opt_no_color,
  @c,

  $daemon_cmd,

  $pidfile_daemon,
  $pidfile_pimpd,
  $pidfile_player,

  $dzen_cmd,
  $dzen_font,

  $player,
  @player_opts,
  $player_stream,
);

file_exists();

# Used for GetOptions()
our(
  @opt_queue,
  $opt_shell,
  @opt_list_external,
  $opt_information,

  $opt_search_artist,
  $opt_search_album,
  $opt_search_title,
  $opt_search_playlist,
  $opt_search_db,
  $opt_search_all_playlists,

  $opt_randomize,
  $opt_randomize_albums,
  $opt_random_track_in_playlist,

  @opt_add_playlist,
  $opt_playlist,
  $opt_write_favlist,
  $opt_parse_favlist,
  $opt_play_from_list,

  $opt_monitor,
  $opt_monitor_d,

  $opt_list_albums,
  $opt_list_songs_on_album,

  $opt_current,
  $opt_np_rt,

  $opt_run_cp,
  $opt_cp_list,
  $opt_cp_album,

  $opt_add_current_album,

  $opt_clear_playlist,

  # So we could override configured settings on the commandline
  $opt_mpd_host,
  $opt_mpd_port,
  $opt_mpd_pass,

);

my(undef, undef, undef, undef, $month, $year) = localtime(time);
$month += 1;
$year  += 1900;

my $player_temp_log = '/tmp/pimpd_player.log';

my $mpd;
if(defined($mpd_host)) {
  $mpd = Audio::MPD->new(
    host      => $mpd_host,
    port      => $mpd_port,
    pass      => $mpd_pass,
  );
}
else {
  $mpd = Audio::MPD->new;
}

GetOptions(
  'i|information'      => \$opt_information,
  'np'                 => \$opt_current,
  'nprt'               => \$opt_np_rt,
  'r|randomize:i'      => \$opt_randomize,
  'ra|random-album:i'  => \$opt_randomize_albums,
  'rt|random-track'    => \$opt_random_track_in_playlist,
  'cp|copy'            => \$opt_run_cp,
  'cpl|cp-list:s{,}'   => sub { shift; cp_list(shift); },
  'cpa|cp-album'       => \$opt_cp_album,
  'f|favorite'         => \$opt_write_favlist,
  'fs|favstats:s'      => sub { shift; favlist_stats(shift); },
  'l|listalbums'       => \$opt_list_albums,
  'lsa|listsongs:i'    => sub
  {
    shift;
    $opt_list_songs_on_album = shift;
    if(!defined($opt_list_songs_on_album) or $opt_list_songs_on_album == 0) {
      # fulhack
      $opt_list_songs_on_album = 'nothing to add';
    }
  },
  'aa|add-album'       => \$opt_add_current_album,
  'pls|list|playlist'  => \$opt_playlist,
  'track'              => \$opt_play_from_list,
  'add=s{1,}'          => \@opt_add_playlist,
  'delete'             => sub { delete_current_album(); },
  'lp|lsp|list-pl'     => sub
  {
    print "$_\n" for sort($mpd->collection->all_playlists);
    exit(0);
  },
  'm|mon|monitor'      => \$opt_monitor,
  'md|monitord'        => \$opt_monitor_d,
  'queue=i{1,}'        => \@opt_queue,
  'shell'              => \$opt_shell,
  'external=s{1,}'     => \@opt_list_external,
  'spl|search-pl=s'    => \$opt_search_playlist,
  'sdb|search-db=s'    => \$opt_search_db,
  'sal|search-album=s' => \$opt_search_album,
  'sar|search-artist=s'=> \$opt_search_artist,
  'set|search-title=s' => \$opt_search_title,
  'sap|favsearch=s'    => \$opt_search_all_playlists,

  'no-color|nocolor'   => \$opt_no_color,
  'c|clear'            => \$opt_clear_playlist,
  'host:s'             => \$opt_mpd_host,
  'port:s'             => \$opt_mpd_port,
  'pass:s'             => \$opt_mpd_pass,
  'ssh_host:s'         => \$ssh_host,
  'ssh_port:s'         => \$ssh_port,
  'ssh_user:s'         => \$ssh_user,

  'play'               => sub { play(); },
  'stop'               => sub { stop(); },

  'kill'               => \&killkid,
  'mpd-kill'           => sub { $mpd->kill; },
  'debug'              => \$DEBUG,
  'h|help'             => \&help,
  'man'                => sub { pod2usage(verbose => 3) },
);

# ... we need to recreate the MPD object
if($opt_mpd_host) {
  $opt_mpd_port = ($opt_mpd_port) ? ($opt_mpd_port) : ($mpd_port);
  $opt_mpd_pass = ($opt_mpd_pass) ? ($opt_mpd_pass) : ($mpd_pass);
  $mpd = Audio::MPD->new(
    host  => $opt_mpd_host,
    port  => $opt_mpd_port,
    pass  => 'void',
  );
}

@c = () if($opt_no_color); # No colors

cp() if($opt_run_cp);

do {
  my $i = 0;
  for(@c) {
    printf("%02d  %s\n", $i, fg($_, $_));
    $i++;
  }
} if($DEBUG);

sub shell_msg_help {
  printf("%s %s\n%s
    $APP $VERSION
    OPTIONS:
        play           start playback
        stop           stop playback
        rand      n    randomize a new playlist with n tracks
        randa     n    add n random albums to a new playlist
        track     n    play track n in playlist
        add       s    add playlist s
        aa        NIL  add the full album of the currently playing song
        sdb       p    search the database for pattern
        sar       p    search for artists matching pattern
        sal       p    search for albums matching pattern
        set       p    search for titles matching pattern
        spl       p    search the playlist for pattern
        fav       NIL  add the current track to the favorites
        favstats  NIL  generate statistics from all favlists
        list      NIL  show the current playlist
        lsa       (n)  list all songs on the current album
        i         NIL  show now playing information
        np        NIL  show the currently playing track
        nprt      NIL  show the currently playing track and progress in realtime
        cp        NIL  copy the currently playing track to specifed location
        cpl       (s)  copy the content of playlist s to specifed location
        rt        NIL  play a random track from the playlist
        n         NIL  next track
        p         NIL  previous track
        s         NIL  shuffle the playlist
        ra        NIL  toggle random on/off
        re        NIL  toggle repeat on/off
        cl        NIL  clear the current playlist
        cr        NIL  crop the current track
        q         n    queue n tracks
        l         NIL  list all albums featuring artist
        e         s    list all tracks in playlist s

        h         NIL  show this help

        exit      NIL  exit


        \n", shift,
      );
}

if($mpd->status->playlistlength < 1) {

  do {
    shell();
  }
    unless($opt_randomize
      or $opt_randomize_albums
      or $opt_search_db
      or $opt_search_album
      or $opt_search_artist
      or $opt_search_title
      or @opt_add_playlist
      or $opt_shell
      or $opt_current
      or @opt_list_external
      or $opt_cp_list
      or $opt_search_all_playlists
  );
}

if($mpd->status->state eq 'stop') {
  $mpd->play;
}

print current(), "\n"                         if $opt_current;
np_realtime(),                                if $opt_np_rt;
information()                                 if $opt_information;
playlist()                                    if $opt_playlist;
write_favlist(shift)                          if $opt_write_favlist;
parse_favlist(generate_fav_struct())          if $opt_parse_favlist;
list_albums()                                 if $opt_list_albums;
list_songs_on_album($opt_list_songs_on_album) if $opt_list_songs_on_album;
play_from_list()                              if $opt_play_from_list;
monitor()                                     if $opt_monitor;

if($opt_monitor_d) {
  if(!defined($daemon_cmd)) {
    print STDERR "No daemon command specified in $config\n" and exit(1);
  }
  if(-e $pidfile_daemon) {
    print STDERR "pimpd is already running\n" and exit(1);
  }
  else {
    monitor();
  }
}
randomize($opt_randomize)                       if $opt_randomize;
randomize_albums($opt_randomize_albums)         if $opt_randomize_albums;
random_track_in_playlist()                      if $opt_random_track_in_playlist;
add_playlist(0, @opt_add_playlist)              if @opt_add_playlist;
add_current_album()                             if $opt_add_current_album;
queue(@opt_queue)                               if @opt_queue;
shell()                                         if $opt_shell;
list_external(@opt_list_external)               if @opt_list_external;
search_playlist($opt_search_playlist)           if $opt_search_playlist;

search_db($opt_search_db)                       if $opt_search_db;
search_album($opt_search_album)                 if $opt_search_album;
search_artist($opt_search_artist)               if $opt_search_artist;
search_title($opt_search_title)                 if $opt_search_title;
search_all_playlists($opt_search_all_playlists) if $opt_search_all_playlists;
cp_list($opt_cp_list)                           if $opt_cp_list;
cp_album()                                      if $opt_cp_album;

sub information {
  my %current = ('artist'     =>  $mpd->current->artist,
                 'album'      =>  $mpd->current->album,
                 'title'      =>  $mpd->current->title,
                 'genre'      =>  $mpd->current->genre,
                 'file'       =>  $mpd->current->file,
                 'date'       =>  $mpd->current->date,
                 'time'       =>  $mpd->status->time->sofar.'/'.
                                  $mpd->status->time->total,
                 'bitrate'    =>  $mpd->status->bitrate,
                 'audio'      =>  $mpd->status->audio,
                 );
  my %status  = ('repeat'     =>  $mpd->status->repeat,
                 'shuffle'    =>  $mpd->status->random,
                 'xfade'      =>  $mpd->status->xfade,
                 'volume'     =>  $mpd->status->volume,
                 'state'      =>  $mpd->status->state,
                 'list'       =>  $mpd->status->playlist,
                 );
  my %stats   = ('song'       =>  $mpd->status->song,
                 'length'     =>  $mpd->status->playlistlength,
                 'songs'      =>  $mpd->stats->songs,
                 'albums'     =>  $mpd->stats->albums,
                 'artists'    =>  $mpd->stats->artists,
                 );

  (undef,undef,undef,undef,undef, my $crnt_year) = localtime(time);
  $crnt_year += 1900;

  if(!($opt_no_color)) { # Use colors
    $current{bitrate} = ($current{bitrate} < 160)
      ? fg($c[5], $current{bitrate})
      : fg($c[10], $current{bitrate})
      ;
  }

  $current{date} = fg('bold', $current{date});

  for(keys(%current)) {
    $current{$_} = fg($c[14], 'N/A') if(!defined($current{$_}));
  }

  $status{state} = 'Playing' if($status{state} eq 'play');
  $status{state} = 'Paused'  if($status{state} eq 'pause');
  $status{state} = 'Stopped' if($status{state} eq 'stop');

  $status{repeat}  = onoff($status{repeat});
  $status{shuffle} = onoff($status{repeat});

  if($status{volume} < 0) {
    $status{volume} = 'N/A (Software Mixer)';
  }

  printf("%s %8s: %.66s\n", fg('bold', fg('251', 'S')),
    'Artist', fg($c[3], fg('bold', $current{artist}))
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('250', 'O')),
    'Album', fg($c[0], $current{album})
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('249', 'N')),
    'Song', fg($c[11], fg('bold', $current{title}))
  );

  printf("%s %8s: %.66s\n", fg('bold', fg(248, 'G')),
    'Genre', fg($c[13], $current{genre})
  );
  printf("%s %9s: %s\n", fg('bold', undef),
    'File', fg($c[7], $current{file})
  );

  printf("%s %8s: %.66s\n", fg('bold', fg('247', 'I')),
    'Date', $current{date}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('246', 'N')),
    'Time', $current{time}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('245', 'F')),
    'Bitrate', $current{bitrate}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('244', 'O')),
    'Audio', $current{audio}
  );

  print fg($c[15]);
  print '-' x 25, clear(), "\n";

  printf("%s %8s: %.66s\n", fg('bold', fg('243', 'S')),
    'Repeat', $status{repeat}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('242', 'T')),
    'Shuffle', $status{shuffle}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('242', 'A')),
    'Xfade', $status{xfade}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('241', 'T')),
    'Volume', $status{volume}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('240', 'U')),
   'State', $status{state}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('239', 'S')),
   'List V', $status{list}
  );

  print fg($c[15]);
  print '-' x 25, clear(), "\n";

  printf("%s %8s: %.66s\n", fg('bold', fg('238', 'S')),
    'Song', $stats{song}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('237', 'T')),
    'List', $stats{length} . ' songs'
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('236', 'A')),
    'Songs', $stats{songs}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('235', 'T')),
    'Albums', $stats{albums}
  );
  printf("%s %8s: %.66s\n", fg('bold', fg('234', 'S')),
   'Artists', $stats{artists}
  );

}

sub randomize {
  my $count = shift // 100;
  my @songs = shuffle($mpd->collection->all_pathes);

  $mpd->playlist->clear if($opt_clear_playlist);
  $mpd->playlist->add(@songs[0 .. $count-1]);
  $mpd->random(1);
  $mpd->repeat(1);
  $mpd->play;

  playlist("Added $count random songs:\n\n");
}

sub randomize_albums {
  my $count  = shift // 10;
  my @albums = shuffle($mpd->collection->all_albums);

  my @songs;
  for(@albums) {
    if($count == 0) {
      last;
    }
    my @songs_on_album = $mpd->collection->songs_from_album($_);
    if(scalar(@songs_on_album) <= 2) {
      next;
    }
    else {
      push(@songs, map { $_->file } @songs_on_album);
      print "$_\n"; # if($DEBUG);
      $count--;
    }
  }
  $mpd->playlist->clear if($opt_clear_playlist);
  $mpd->playlist->add(@songs);
  #$mpd->random(0);
  $mpd->play(0);
  play();
  return 0;
}

sub random_track_in_playlist {
  if(playlist_is_empty()) {
    print STDERR "Playlist is empty - nothing to play\n";
    return 1;
  }
  my @items = $mpd->playlist->as_items;
  if(!@items) {
    print "uh, uh...\n";
    return 1;
  }
  @items = shuffle(@items);
  $mpd->play($items[0]->pos);
  print current('show') . "\n";
}

sub delete_current_album {
  my $file = $mpd->current->file;
  my($album) = $file =~ m;(.+)/.+$;;
  $album = "$basedir/$album";
  $album =~  s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;

  if(defined($mpd_host)) {
    printf("Remove \e[1m%s\e[0m ? [y/N] ", $album);
    chomp(my $answer = <STDIN>);
    if(lc($answer) ne 'y') {
      return 1;
    }
    else {
      system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
        "rm -rv $album");
    }
  }
  else {
    printf("Remove \e[1m%s\e[0m ? [y/N] ", $album);
    chomp(my $answer = <STDIN>);
    if(lc($answer) ne 'y') {
      return 1;
    }
    else {
      if(remove_path($album)) {
        printf("%s deleted\n", $album);
        return 0;
      }
      else {
       print "$!\n";
      }
    }
  }
  return 0;
}

sub playlist {
  my $header = shift;
  $header = "Playlist:\n" if($header eq 'show');

  my @playlist = $mpd->playlist->as_items;

  print $header;

  my $i = 0;
  for my $song(@playlist) {
    my $title  = $song->title  // 'undef';
    my $artist = $song->artist // 'undef';


    my $crnt_title  = $mpd->current->title // undef;
    my $crnt_artist = $mpd->current->artist // undef;
    $title       =~ s/(\w+)/\u\L$1/g;
    $artist      =~ s/(\w+)/\u\L$1/g;
    $crnt_title  =~ s/(\w+)/\u\L$1/g;
    $crnt_artist =~ s/(\w+)/\u\L$1/g;

    if($mpd->current->pos == $i) {
      printf("%4d %25.25s |x| %-47.47s\n",
        $i, $artist, $title);

    }
    else {
      printf("%4d %25.25s | | %-47.47s\n",
        $i, $artist, $title);
    }
    $i++;
  }
  print "\n" . current('show'), "\n";
}

sub search_all_playlists {
  my $query = shift;

  if(!defined($query) or $query eq '') {
    print STDERR "No query specified\n";
    return 1;
  }
  if(invalid_re($query)) {
    print STDERR "$query is not valid regex. See 'perldoc perlretut'\n";
    return 1;
  }

  my @matched_files;

  open(my $fh, '<', $favlist_db_global) or die($!);
  while(<$fh>) {
    if($_ =~ /$query/i) {
      my ($artist, $album, $title, $genre, $file)
        = $_ =~ /"(.+)", "(.+)", "(.+)", "(.+)", "(.+)"/;

      printf("%s %s\n", fg($c[15], $artist), fg($c[3], $title));

      # Fulhack. The absolute path might be needed for other applications and
      # that's the reason why the basedir is here in the first place
      # MPD doesnt like it though.
      $file =~ s;$basedir/;;;
      push(@matched_files, $file);
    }
  }
  close($fh);
  $mpd->playlist->add(@matched_files);
  return 0;
}

sub daemonize {
  my $daemon_log = shift // '/dev/null';
  use POSIX 'setsid';
  my $PID = fork();
  exit(0) if($PID); #parent
  exit(1) if(!defined($PID)); # out of resources

  setsid();
  $PID = fork();
  exit(1) if(!defined($PID));

  if($PID) { # parent
    waitpid($PID, 0);
    unlink($pidfile_daemon); # remove the lock when child have died
    exit(0);
  }
  elsif($PID == 0) { # child
    open(my $fh, '>', $pidfile_daemon) or die("Cant open $pidfile_daemon: $!");
    print $fh $$;
    close($fh);
    open(STDOUT, '>', $daemon_log);
    open(STDERR, '>', '/dev/null');
    open(STDIN,  '<', '/dev/null');
  }
}

sub killkid {
  open(my $fh, '<', $pidfile_pimpd) or return 1; # for now
  my $pimpd_player = <$fh>;
  close($fh);

  if(kill(9, $pimpd_player)) {
    unlink($player_temp_log);
    printf("%d %s\n", fg('bold', $pimpd_player), 'terminated') if($DEBUG);
  }

  open(my $fh, '<', $pidfile_player) or die($!);
  my $pimpd_target = <$fh>;
  close($fh);

  if(kill(9, $pimpd_target)) {
    printf("%d %s\n", fg('bold', $pimpd_target, 'terminated')) if($DEBUG);
  }

  if(kill(9, $pimpd_target+1)) {
    printf("%d %s\n", fg('bold', $pimpd_target + 1), 'terminated') if($DEBUG);
  }
  return 0;
}

sub player_connect {
  if(!defined($player)) {
    #print STDERR "No player configured\n";
    return 1;
  }
  if(!defined($player_stream)) {
    #print STDERR "No stream configured\n";
    return 1;
  }

  my $fails = 0;

  # Not playing!
  if(! -e $player_temp_log) {
    player_daemonize($player_temp_log);
    exec($player, @player_opts, $player_stream);
  }
  else {
    open(my $fh, '<', $player_temp_log);
    while(<$fh>) {
      if(/Exiting\.\.\. \(End of file\)/) {
        $fails++;
        # fulhack. Time::HiRes
        select(undef, undef, undef, 0.50);
        if($fails == 15) {
          last;
        }
      }
    }
    close($fh);
  }
  if($fails == 15) {
    unlink($player_temp_log);
    #killkid();
    return 0;
  }
  else {
    player_daemonize($player_temp_log);
    exec($player, @player_opts, $player_stream);
  }
  return 0;
}


sub player_daemonize {
  my $daemon_log = shift // '/dev/null';
  use POSIX 'setsid';
  my $PID = fork();
  exit(0) if($PID); #parent
  exit(1) if(!defined($PID)); # out of resources

  setsid();
  $PID = fork();
  exit(1) if(!defined($PID));

  if($PID) { # parent
    open(my $fh, '>', $pidfile_pimpd) or die($!);
    print $fh $$;
    close($fh);

    waitpid($PID, 0);
    #unlink($pidfile); # remove the lock when child have died

    # Child have died/returned.
    # This means that MPD is in a state where it's not sending any data
    # We try to reconnect 15 times with a delay, and if the stream is still
    # down, we exit. See player_connect()
    player_connect($player_stream);
    exit(0);
  }
  elsif($PID == 0) { # child
    open(my $fh, '>', "$pidfile_player") or die("pidfile $pidfile_player: $!");
    print $fh $$;
    close($fh);
    open(STDOUT, '>>',  $daemon_log);
    open(STDERR, '>', '/dev/null');
    open(STDIN,  '<', '/dev/null');
  }
  return 0;
}

sub play {
  #undef $player if($DEBUG);
  killkid(); # FIXME
  $mpd->play;
  player_connect();

  #if(player_connect() == 1) {
  #  $mpd->play;
  #}
}

sub stop {
  $mpd->stop;
  #unlink($player_temp_log);
  killkid();
}

sub add_playlist {
  my $clear_or_not = shift; # clear playlist?
  if(@_) {
    if( ($_[0] eq 'all') and (not('all' ~~ $mpd->collection->all_playlists)) ) {

      print "Adding all playlists\n";
      my @all = $mpd->collection->all_playlists;
      $mpd->playlist->clear if($opt_clear_playlist);
      for(@all) {
        $mpd->playlist->load($_);
      }
      $mpd->play;
      return 0;
    }

    my @playlists = @_;
    @playlists = is_existing_list(@playlists);

    return 1 if(!@playlists);

    $mpd->playlist->clear if($opt_clear_playlist);

    $mpd->playlist->load($_) for @playlists;
    print "Adding ";
    printf fg('bold', $_) for @playlists;
    print "\n";

    $mpd->play;
  }
}

sub list_external {
  my @playlists = @_;

  @playlists = is_existing_list(@playlists);
  for my $playlist(@playlists) {
    my $full_path = "$playlist_dir/$playlist\.m3u";

    my $fh = undef;
    if(defined($mpd_host)) {
      #$full_path =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
      open($fh, "ssh -p $ssh_port $ssh_user\@$ssh_host \"/bin/cat '$full_path'\"|")
        or die("$ssh_host:$ssh_port: $!");
    }
    else {
      open($fh, '<', $full_path) or die("Can not open $full_path: $!");
    }
    while(<$fh>) {
      print fg($c[4], $playlist), ': ', fg($c[10], $_);
    }
    close($fh);
  }
  return 0;
}

sub scp {
  my($host, $port, $src, $dest) = @_;

  # fulhack, FIXME
  $src =~ s;^$basedir/($basedir/.+);$1;;

  # ~  - if a filename contains this, fun stuff could happen
  # =  - one could set env vars if not escaping this
  $src  =~ s/([;\\<\n\=\~>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
  #$dest =~ s/([;\\<\n\=\~>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
  #$dest =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;

  # FIXME let scp's fail
  system('scp', '-r',  "-P $port", "$host:$src", $dest) == 0 or croak("scp: $!");
  return 0;
}

sub cp {
  my $dest = shift // $portable;

  is_existing_dir($dest);

  chomp(my $file = $mpd->current->file);

  # escape evil chars the shell will munch
  $file =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g unless(defined($mpd_host));

  if(defined($mpd_host)) {
    return scp($ssh_host, $ssh_port, "$basedir/$file", $dest)
  }

  if(copy("$basedir/$file", $dest)) {
    my($basename) = $file =~ m;.+/(.+)$;;
    print fg('bold', fg($c[4], $basename)), ' => ', fg($c[6], $dest), "\n";
  }
  else {
    print STDERR "cp: $basedir/$file $!\n";
  }
  return 0;
}

sub is_existing_dir {
  my $dir = shift;

  if(-e $dir && ! -d $dir) {
    print STDERR "$dir exists, but is not a directory\n";
    print STDERR "Delete and mkdir $dir?\n";

    chomp(my $choice = <STDIN>);

    if(lc($choice ne 'y')) {
      print STDERR "Bailing out\n";
      return 1;
    }
    else {
      if(unlink($dir)) {
        print "$dir removed successfully\n";
      }
      else {
        print STDERR "Could not remove $dir: $!\n";
        return 1;
      }
    }
  }
  elsif(! -d $dir) {
    if(make_path($dir, 1, 0777)) {
      print fg($c[5], '>>'), fg('bold', "$dir created"), "\n\n";
    }
    else {
      print STDERR "Could not mkdir $dir: $!\n";
    }
  }
}

sub cp_album {
  my $dest = shift // $portable;

  is_existing_dir($dest);

  if(! -d $dest) {
    if(make_path("$dest", 1, 0777)) {
      print "$dest $c[15]created\e[0m";
    }
    else {
      print STDERR "Could not create $dest: $!\n";
      return 1;
    }
  }

  my $file = $mpd->current->file;
  return 1 if(!$file);

  my $path  = "$basedir/$file";
  my($basename) = $path  =~ m;.+/(.+)$;;
  my($album)    = $path  =~ m;(.+)/.+$;;
  my($albname)  = $album =~ m;.+/(.+)$;;

  $basename =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
  $album    =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;

  do {
    print "PATH: $path\n";
    print "BASENAME: $basename\n";
    print "ALBUM: $album\n";
    print "ALBNAME: $albname\n";
  } if($DEBUG);

  printf("%50.70s => %s\n",  fg($c[11], fg('bold', $albname)), $dest);

  if(defined($mpd_host)) {
    my @files = grep{ /\.(?:mp3|ogg|flac|wav)$/ } `ssh -p $ssh_port $ssh_user\@$ssh_host 'find "$album"'`;
    for(@files) {
      chomp;
      $_ =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
    }

    open(OLD_STDOUT, '>&', STDOUT) or die($!);
    close(STDOUT);

    for(@files) {
      my ($basename) = $_ =~ m;.+/(.+)$;;
      if(scp($ssh_host, $ssh_port, $_, $dest) == 0) {
        # Yes, we are abusing STDERR here. Sorry :)
        printf STDERR ("%42.70s\n", $basename);
      }
      else {
        print STDERR "$!\n";
      }
    }
    open(STDOUT, '>&', OLD_STDOUT) or die($!);
  }
  else {
    for(grep{ /\.(?:mp3|ogg|flac|wav)$/ } glob("$album/*")) {
      my ($basename) = $_ =~ m;.+/(.+)$;;
      if(copy($_, $dest)) {
        printf("%50.50s\n", $basename);
      }
      else {
        print STDERR "$_: $!\n";
        return 1;
      }
    }
  }
  return 0;
}

sub is_existing_list {
  my @lists       = @_;
  my @valid_lists = sort($mpd->collection->all_playlists);

  for my $list(@lists) {
    if($list ~~ @valid_lists) {
      next;
    }
    else {
      my @choices = ();

      for my $valid(@valid_lists) {
        if($valid =~ /$list/i) {
          push(@choices, $valid);
        }
      }
      if(scalar(@choices) == 0) {
        print STDERR "No such playlist ' " . fg($c[5], $list), "\n";
        return;
      }

      my $i = 0;
      for my $choice(@choices) {
        print fg('bold', sprintf("%3d", $i)), " $choice\n";
        $i++;
      }
      print "choice: ";
      chomp(my $answer = <STDIN>);

      if($answer eq 'all') {
        return(@choices); # return all matched lists
      }
      elsif($answer eq 'current') {
        return(undef);
      }
      if($answer ~~ @valid_lists) {
        $list = $answer;
      }
      # Make sure the number selected is in fact valid
      elsif($answer >= 0 and $answer <= scalar(@valid_lists)) {
        $list = $choices[$answer];
      }
      else {
        print STDERR "Playlist $answer is not valid\n";
        return 1;
      }
    }
  }
  return(@lists);
}


sub cp_list {
  my @lists = @_;
  my $dest  = $portable;

  is_existing_dir($dest);
  @lists = is_existing_list(@lists);

  # No list specified, use the current playlist
  if(!@lists) {
    my @files = map { $_ = "$basedir/" . $_->file; } $mpd->playlist->as_items;
    if(defined($mpd_host)) {
      for my $file(@files) {
        #$file =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
        #$file =~ s/(\s+)/\\$1/g;
        scp($ssh_host, $ssh_port, $file, $dest);
      }
    }
    else {
      for my $file(@files) {
        #$file =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
        $file =~ s/(\s+)/\\$1/g;
        if(copy($file, $dest)) {
          printf("[%5.20s] %50.50s => %s\n",
            fg($c[6], 'current'), fg('bold', $file), $dest);
        }
        else {
          print STDERR "cp_list(): $!\n";
        }
      }
    }
    return 0;
  }

  my %playlist_map;

  for my $playlist(@lists) {
    my $full_path = "$playlist_dir/$playlist\.m3u"; #FIXME

    my $fh = undef;

    if(defined($mpd_host)) {
      open($fh, "ssh -p $ssh_port $ssh_user\@$ssh_host \"/bin/cat '$full_path'\"|")
        or die("cp_list(): $ssh_host:$ssh_port: $!");
    }
    else {
      open($fh, '<', $full_path) or die("Can not open $full_path: $!");
    }

    while(<$fh>) {
      chomp;
      $playlist_map{$_} = $playlist;
    }
    close($fh);
  }

  print "\n---\n";

  for my $file(keys(%playlist_map)) {
    my $full = "$basedir/$file";

    if(defined($mpd_host)) {
      #$full =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
      scp($ssh_host, $ssh_port, $full, $dest);
    }
    else {
      my($basename) = $file =~ m;.+/(.+)$;;
      if(copy($full, $dest)) {
        printf("[%5.11s] %50.50s => %s\n",
          fg($c[6], $playlist_map{$file}), $basename, $dest);
      }
      else {
        print STDERR "cp_list(): $!\n";
        return 1;
      }
    }
  }
  return 0;
}

sub file_exists {
  my $rc = undef;
  if(defined($mpd_host)) {
    system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
       'test', '-d', $ENV{XDG_DATA_HOME}
     );
    $rc = $?;

    if($rc == 1) { # XDG_DATA_HOME is defined
      $rc = undef;
      system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
        'test', '-d', "$ENV{XDG_DATA_HOME}/pimpd"
      );
      $rc = $?;
      if($rc == 0) { # the pimpd dir doesnt exist
        system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
          'mkdir', '-p', "$ENV{XDG_DATA_HOME}/pimpd"
        );
        $favlist_db_dir = `ssh -p $ssh_port $ssh_user\@$ssh_host \"printf $ENV{XDG_DATA_HOME}/pimpd\"`;
      }
    }
    else {
      system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
        'mkdir', '-p', "$ENV{HOME}/.local/share/pimpd"
      );
      $favlist_db_dir = `ssh -p $ssh_port $ssh_user\@$ssh_host \"printf $ENV{HOME}/.local/share/pimpd\"`;
    }
  }
  elsif(defined($ENV{XDG_DATA_HOME})) {
    if(! -d "$ENV{XDG_DATA_HOME}/pimpd") {
      make_path("$ENV{XDG_DATA_HOME}/pimpd", 1, 0777);
    }
    $favlist_db_dir = "$ENV{XDG_DATA_HOME}/pimpd/";
  }
  else {
    if(! -d "$ENV{HOME}/.local/share/pimpd") {
      make_path("$ENV{HOME}/.local/share/pimpd", 1, 0777);
    }
    $favlist_db_dir = "$ENV{HOME}/.local/share/pimpd";
  }

  if(!-e $favlist_db_global) {
    open(my $fh, '>', $favlist_db_global) or warn($!);
    close($fh);
  }
}

sub write_favlist {
  my $artist = $mpd->current->artist // 'undef';
  my $album  = $mpd->current->album  // 'undef';
  my $title  = $mpd->current->title  // 'undef';
  my $genre  = $mpd->current->genre  // 'undef';
  my $file   = $basedir . '/' . $mpd->current->file;

  my(undef, undef, undef, undef, $month, $year) = localtime(time);
  $month += 1;
  $year  += 1900;

  my $favlist_db_monthly  = $favlist_db_dir
    . sprintf("%d-%02d.favlist", $year, $month);

  my $favlist_m3u = $playlist_dir . "/"
    . sprintf("%d-%02d_%s.m3u", $year, $month, $genre);


  my $fh = undef;

  if(defined($mpd_host)) {
    # 'Illegal seek'... why? It seems to work anyway, so dont die here, for now
    # Regular m3u
    system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
      "echo '$file' >> $favlist_m3u"
      );
    my ($basename) = $file =~ m;.+/(.+)$;;
    printf("%s >> %s\n",
      fg($c[3], $basename), fg('bold', $ssh_host) . ":$favlist_m3u");

    # Full DB
    my $full_str = sprintf("\"%s\", \"%s\", \"%s\", \"%s\", \"%s\"",
      $artist, $album, $title, $genre, $file
    );
    # TODO Shouldnt these be local?
    system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
      "echo '$full_str' >> $favlist_db_global"
    );

    # Monthly
    system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
      "echo '$full_str' >> $favlist_db_monthly"
    );
    return 0;
  }

  # Monthly
  open(my $fh, '>>', $favlist_db_monthly) or die($!);
  print $fh "\"$artist\", \"$album\", \"$title\", \"$genre\", \"$file\"\n";
  close($fh);

  # Full DB
  open(my $fh, '>>', $favlist_db_global) or die($!);
  print $fh "\"$artist\", \"$album\", \"$title\", \"$genre\", \"$file\"\n";
  close($fh);

  # Regular m3u
  open(my $fh, '>>', $favlist_m3u) or die($!);
  print $fh "$file\n";
  close($fh);

  print fg($c[8], fg('bold', $title)), ' => ', fg($c[6], $favlist_m3u), "\n";

  return 0;
}

sub generate_fav_struct {
  my(undef, undef, undef, undef, $month, $year) = localtime(time);
  $month += 1;
  $year  += 1900;

  my $favlist_db  = $favlist_db_dir
    . sprintf("%d-%02d.favlist", $year, $month);

  my %fav_struct = ();
  my $fh = undef;

  if(defined($mpd_host)) {
    open($fh, "ssh -p $ssh_port $ssh_user\@$ssh_host \"/bin/cat '$favlist_db_global'\"|")
      or die($!);
  }
  else {
    open($fh, '<', $favlist_db) or die("$favlist_db: $!");
  }
  while(<$fh>) {
    chomp;

    my($artist, $album, $title, $genre, $file) = split(/,/, $_);

    $artist =~ s/"(.+)"/$1/;
    $album  =~ s/"(.+)"/$1/;
    $title  =~ s/"(.+)"/$1/;
    $genre  =~ s/"(.+)"/$1/;
    $file   =~ s/"(.+)"/$1/;

    push(@{$fav_struct{$artist}{$album}{$title}{$genre}}, $file)
      unless($file ~~ @{$fav_struct{$artist}{$album}{$title}{$genre}});
  }
  return(\%fav_struct);
}

sub parse_favlist {
  my $fav    = shift;
  my($tag, $query) = @_; # album 'Best of';

  my $i = 0;
  for my $artist(keys(%{$fav})) {
    for my $album(keys(%{$fav->{$artist}})) {
      for my $title(keys(%{$fav->{$artist}{$album}})) {
        for my $genre(keys(%{$fav->{$artist}{$album}{$title}})) {

          print fg('bold',fg('blue10', $album));
          for my $song_on_album(sort(@{$fav->{$artist}{$album}{$title}{$genre}})) {

            my($albname) = $song_on_album =~ m;.+/(.+)$;;

            if($albname =~ /($query)(.*)/gpi) {
              $albname = ${^PREMATCH} . fg('bold', fg($c[15])) . $2;
            }
            printf("% 2d\t%s\n", $i, $title);
            $i++;
          }
        }
      }
    }
  }
}

sub favlist_stats {
  my $display_all = shift;

  my(undef, undef, undef, undef, $month, $year) = localtime(time);
  $month += 1;
  $year  += 1900;
  my $favlist_db  = $favlist_db_dir
    . sprintf("%d-%02d.favlist", $year, $month);

  my(%artists, %albums, %titles, %genres, %files);

  my $fh = undef;

  if(defined($mpd_host)) {
    open($fh, "ssh -p $ssh_port $ssh_user\@$ssh_host \"/bin/cat '$favlist_db_global'\"|")
      or die($!);
  }
  else {
    open($fh, '<', $favlist_db_global) or die("$favlist_db: $!");
  }

  while(<$fh>) {

    my($artist, $album, $title, $genre, $file) = undef;

    $_  =~ m/"(.+)", "(.+)", "(.+)", "(.+)", "(.+)"/;

    # We have to do the checks backwards
    $file  = (defined($5)) ? $5 : 'undef';
    $genre = (defined($4)) ? $4 : 'undef';
    $title = (defined($3)) ? $3 : 'undef';
    $album = (defined($2)) ? $2 : 'undef';
    $artist= (defined($1)) ? $1 : 'undef';


    #my($artist, $album, $title, $genre, $file) = split(/,/, $_);

    # We're not interested in favs with missing tags
    $artists{$artist}++ unless($artist eq 'undef');
    $albums{$album}++   unless($album  eq 'undef');
    $titles{$title}++   unless($title  eq 'undef');
    $genres{$genre}++   unless($genre  eq 'undef');
    $files{$file}++;
  }



  printf("%30s %s\n", 'Count', 'Artist') unless(!$display_all);

  for(sort { $artists{$b} <=> $artists{$a} } keys(%artists)) {
    if($display_all) {
      printf("%20d %s\n", $artists{$_}, $_);
    }
    else {
      printf("%s %s %s\n", 'Favorite artist:', $_ , "($artists{$_})");
      last;
    }
  }
  printf("%27s\n", 'Album') unless(!$display_all);
  for(sort { $albums{$b} <=> $albums{$a} } keys(%albums)) {
    if($display_all) {
      printf("%20d %s\n", $albums{$_}, $_);
    }
    else {
      printf("%s %s %s\n", 'Favorite album:', $_ , "($albums{$_})");
      last;
    }
  }
  printf("%27s\n", 'Genre') unless(!$display_all);
  for(sort { $genres{$b} <=> $genres{$a} } keys(%genres)) {
    if($display_all) {
      printf("%20d %s\n", $genres{$_}, $_);
    }
    else {
      printf("%s %s %s\n", 'Favorite genre:', $_ , "($genres{$_})");
      last;
    }
  }
}

sub list_albums {
  my $artist = $ARGV[0] // $mpd->current->artist;
  my @albums = sort($mpd->collection->albums_by_artist($artist));

  for(sort(@albums)) {
    print "$_\n";
  }
  printf("%s is featured on %s albums\n",
    fg($c[2], fg('bold', $artist)), fg($c[4], fg('bold', scalar(@albums))));
}

sub list_songs_on_album {
  my $num = shift;

  #FIXME Add 'all' tracks on album

  my $album = $mpd->current->album;
  if(!defined($album) or $album eq '') {
    print STDERR "Album tag missing!\n";
    return 1;
  }
  my @tracks = $mpd->collection->songs_from_album($album);

  if(defined($num) and $num ne 'nothing to add') {
    if($num > scalar(@tracks)) {
      print STDERR "There are " . scalar(@tracks)
        . " songs on ". fg($c[1], $album), "\n";
      return 1;
    }
    my $file = $tracks[$num]->file;
    $mpd->playlist->add($file);
    printf("Added %s - %s\n",
      fg('bold', $tracks[$num]->artist), $tracks[$num]->title);

    return 0;
  }

  my $i = 0;
  printf("%s\n", fg('bold', fg($c[4], $album)));

  for(@tracks) {
    printf("% 3s %50.50s %s\n", $i, $_->title, sec_and_min($_->time));
    $i++;
  }
  return 0;
}

sub add_current_album {
  my $album = $mpd->current->album;

  if(!defined($album) or $album eq '') {
    print STDERR "No album tag\n";
    return 1;
  }

  my @tracks = $mpd->collection->songs_from_album($album);

  $mpd->playlist->clear if($opt_clear_playlist);
  for(@tracks) {
    printf("%s\n", $_->title);
    $mpd->playlist->add($_->file);
  }

}


sub play_from_list {
  my $choice = $ARGV[0] // shift;
  if(!defined($choice)) {
    print STDERR "What should we play?\n";
    exit(1);
  }

  if($choice !~ /^\d+$/) {
    print STDERR "Integers only, please.\n";
  }
  if($choice > $mpd->status->playlistlength) {
    print STDERR "There are " .fg('bold',  $mpd->status->playlistlength)
      . "songs in the playlist. Pick one of them!\n";
      return 1;
  }
  $mpd->play($choice -1);
  print current(), "\n";
}


sub monitor {
  my $np = "";
  unless($DEBUG) {
    daemonize if($opt_monitor_d);
  }

  while(1) {
    my $current = $mpd->current;
    return 1 if(!defined($current)); # not running?
    my $output;
    if($opt_monitor_d) {
      my $artist = $mpd->current->artist // 'undef';
      my $album  = $mpd->current->album  // 'undef';
      my $title  = $mpd->current->title  // 'undef';
      my $genre  = $mpd->current->genre  // 'undef';
      my $year   = $mpd->current->date   // 0;

      #NOTE Ugly. Make configureable..
      if($daemon_cmd eq 'dzen') {
        $output = sprintf(
          "^fg(#4af617)%s ^fg(#999999)by^fg() ^fg(#fa4b04)%s^fg(#999999)",
            $title, $artist
            . sprintf(" (^fg(#fa0443) %s^fg(#999999) ) ", $album)
            . sprintf("^fg(#999999)from ^fg(#1c79ed)%s^fg()", $year)
          );
      }
      else {
        $output = sprintf("%s (%s) %s | %s", $artist, $album, $title, $genre);
      }
    }

    if("$np" ne "$current") {
      $np = $current;

      if($opt_monitor_d) {
        if($daemon_cmd eq 'dzen') {
          system("echo \"$output\" | $dzen_cmd");
        }
        else {
          system("$daemon_cmd \"$output\"");
        }
      }
      else {
        my @date = localtime(time);
        my @rc = shuffle(@c);
        my $file = $mpd->current->file;
        printf("%02d:%0ds:%0ds | %.90s\n",
          $date[2], $date[1], $date[0], fg($rc[0], $file));
        print clear();
      }
    }
    sleep 2;
  }
}

sub queue {
  my @to_play = @_;
  if(scalar(@to_play < 1)) {
    print STDERR "The queue function requires at least one song \n";
    return 1;
  }

  #@to_play = map{ $_ = $_ - 1 } @to_play;
  for(@to_play) {
    if(invalid_pos($_)) {
      print STDERR fg($c[5], $_), ": invalid position\n";
      return 1;
    }
  }

  my %list = ();
  map { $list{$_->pos} = $_->title } $mpd->playlist->as_items;


  $mpd->random(0);
  $mpd->play(shift(@to_play));
  $mpd->playlist->move($mpd->current->pos, 0);

  return 0 if(scalar(@to_play) == 0);


  my $next_pos = $mpd->current->pos + 1;
  print fg('bold', 'Queueing'), ":\n";
  for(@to_play) {
    printf("%-50.50s %s\n", fg($c[3], $list{$_}), "( $_ => $next_pos )");
    #print "$_ => ", fg('bold', $next_pos), "\n" if($DEBUG);

    $mpd->playlist->move($_, $next_pos);
    $next_pos++;
  }
}

sub np_realtime {
  my $np = "";

  # Make the cursor visible before exiting
  # Yes, this only works in xterms and rxvt's.
  # It shoulnd't do anything at all for people using other VTs
  $SIG{INT} = sub { printf("\e[?25h"); exit(0); };

  while(1) {
    my $current = $mpd->current;
    my $output  = undef;
    if(!$current) {
      ($output, $current) = 'undef' x 2;
    }
    else {
      $output = sprintf("%s - %s - %s",
        fg('bold', fg($c[7], $mpd->current->artist)),
        $mpd->current->album,
        fg($c[12], $mpd->current->title),
      );
    }
    my $played_time = $mpd->status->time->sofar;
    my $total_time  = $mpd->status->time->total;

    $|++;
    # Hide the cursor
    printf("\e[?25l");
    printf("[%s/%s\r",
      $played_time,
      fg('bold', $total_time),
    );

    if("$np" ne "$current") {
      $np = $current;
      printf("\t\t%s\r", $output);
    }
    sleep 1;
  }
}

sub shell {
  my $option = shift;
  my($cmd, $arg, @cmd_args); # for later use
  shell_msg_help();

  my $opts = {
    'rand'    => sub {
      if(!defined($_[0])) {
        $_[0] = 100;
      }
      elsif(defined($_[0]) and $_[0] !~ /^\d+$/) {
        print STDERR "Need a valid integer\n";
        $_[0] = 100;
      }
      print 'Adding ' . fg('bold', @_) . " random tracks...\n";

      $opt_clear_playlist = 1;
      randomize(@_);
    },
    'randa'   => sub {
      randomize_albums($_[0]);
    },

    'list'      => sub {
      if(playlist_is_empty()) {
        print STDERR "Playlist is empty\n";
        return 1;
      }
      playlist();
    },

    'fav'       => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      write_favlist(@_);
    },
    'favstats'  => sub {
      if($_[0] eq 'all') {
        favlist_stats(1);
      }
      else {
        favlist_stats(0);
      }
    },

    'track'      => sub {
      @_[0] = 1 if @_[0] !~ /^\d+$/;
      play_from_list(@_);
    },

    'cp'        => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      cp();
    },

    'cpa'       => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      cp_album();
    },

    'cpl'       => sub { cp_list(@_); },
    'i'         => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      information();
    },

    'mon'       => sub {
      if(playlist_is_empty()) {
        print STDERR "Playlist is empty - there's nothing to monitor\n";
        return 1;
      }
      monitor();
    },

    'sar'       => sub {
      my $artist = join(' ', @_);
      search_artist($artist);
    },

    'sal'       => sub {
      my $album = join(' ', @_);
      search_album($album);
    },

    'set'       => sub {
      my $title = join(' ', @_);
      search_title($title);
    },

    'sdb'       => sub {
      my $search = join(' ', @_);
      search_db($search);
    },

    'spl'       => sub {
      my $search = join(' ', @_);
      search_playlist($search);
    },

    'sap'       => sub {
      my $search = join(' ', @_);
      search_all_playlists($search);
    },

    'l'         => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      list_albums();
    },
    'lsa'       => sub { list_songs_on_album(@_); },

    'e'         => sub { list_external(@_); },

    # The 0 argument makes sure we're not clearing the playlist
    # NOTE: Not really neccessary anymore
    'add'       => sub { add_playlist(0, @_); },

    'n'         => sub {
      if(playlist_is_empty()) {
        print STDERR "Playlist is empty!\n";
        return 1;
      }
      $mpd->next;
      print current() . "\n";
    },

    'p'         => sub {
      if(playlist_is_empty()) {
        print STDERR "Playlist is empty!\n";
        return 1;
      }
      $mpd->prev;
      print current() . "\n";
    },

    't'         => sub {
      $mpd->pause;
      print $mpd->status->state . "\n";
    },

    's'         => sub {
      $mpd->playlist->shuffle;
      print "New playlist version is " .$mpd->status->playlist . "\n"
    },

    'np'        => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      print current() . "\n";
    },

    'nprt'      => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      np_realtime();
    },

    'q'         => sub {
      if(invalid_pos(@_)) {
        printf("No such song%s\n", (@_ < 1) ? 's' : '');
        return 1;
      }
      queue(@_);
    },

    'ra'        => sub {
      $mpd->random;
      my $status =  ($mpd->status->random)
        ? "Random: " . fg('bold', 'On')
        : "Random: " . fg('bold', 'Off');
      print "$status\n";
    },

    're'        => sub {
      $mpd->repeat;
      my $status = ($mpd->status->repeat)
        ? "Repeat: " . fg('bold', 'On')
        : "Repeat: " . fg('bold', 'Off');
      print "$status\n";
    },

    'rt'        => sub { random_track_in_playlist(); },
    'aa'        => sub { add_current_album(); },
    'cl'        => sub { $mpd->playlist->clear; },
    'cr'        => sub { $mpd->playlist->crop; },
    'stop'      => sub { stop(); },
    'play'      => sub {
      if(playlist_is_empty()) {
        print STDERR "Nothing is playing - playlist is empty\n";
        return 1;
      }
      play();
    },
    'h'         => sub { shell_msg_help(); },
    'exit'      => sub { exit(0); },
  };

  while(1) {
    print fg($c[6], 'pimpd'), fg('bold', '> ');

    chomp(my $choice = <STDIN>);
    ($cmd) = $choice =~ m/^(\w+)/;
    ($arg) = $choice =~ m/\s+(.+)$/;
    @cmd_args  = split(/\s+/, $arg);

    print "cmd: $cmd\narg: @cmd_args\n" if($DEBUG);

    if(defined($opts->{$cmd})) {
      $mpd->play;
      $opts->{$cmd}->(@cmd_args);
    }
    else {
      $opts->{h}->();
      print STDERR "No such option ", fg($c[5], $cmd), "\n";
    }
  }
  exit(0);
}

sub search_playlist {
  my $search   = shift;

  my %playlist = undef;

  for($mpd->playlist->as_items) {
    $playlist{pos}->{$_->pos} = join(' - ', $_->artist, $_->album, $_->title);
  }

  if(invalid_re($search)) {
    print STDERR "'$search' is not valid regex. See 'perldoc perlretut'\n";
    return 1;
  }

  # NOTE Should we ignore dupes?
  # All Saints = Pure Shores <=> All Saints - Pure Shores
  # Or maybe compare by album as well. Crap could be live, remixes and what not,
  # even though the title doesnt say so.
  # Or maybe we should just let the user craft their regex good enough :)

  my @found = ();
  # 'pos'
  for my $pos(keys(%playlist)) {
    # 42
    for my $pos_no(keys(%{$playlist{$pos}})) { # 42
      # Laleh Me and Simon Big City Love
      if($playlist{$pos}{$pos_no} =~ /($search)(.*)/gpi) {
        push(@found, $pos_no);

        # GNU Grep like color-matching
        print ${^PREMATCH}, fg('bold', fg($c[1], $1)), "$2\n";
      }
    }
  }

  if(scalar(@found) < 1) {
    print STDERR
      "No match on ' ",
      fg('bold', $search),
      "' in the current playlist\n";

    return 1;
  }
  #@found = map { $_ = $_ +1 } @found; # fulhack
  queue(@found);
}

sub search_db {
  my $search = shift;

  if(invalid_re($search)) {
    print STDERR "'$search' is not valid regex. See 'perldoc perlretut'\n";
    return 1;
  }

  for($mpd->collection->all_pathes) {
    if($_ =~ /$search/i) {
      printf("> %.77s\n", $_);
      $mpd->playlist->add($_);
    }
  }
  $mpd->play;
}

sub search_album {
  my $search = shift;
  my @albums = $mpd->collection->songs_from_album_partial($search);
  if(!@albums) {
    print ">> ", fg($c[2], $search), ": no albums found\n";
    return 1;
  }
  map { $_ = $_->file } @albums;
  pipe_add(@albums);

  printf(">> Found %s songs on albums matching '%s'\n",
    fg('bold', fg($c[6], scalar(@albums))),
    fg('bold', fg($c[5], $search)),
  );
}

sub search_artist {
  my $search = shift;
  my @artists = $mpd->collection->songs_by_artist_partial($search);
  if(!@artists) {
    print ">> ", fg($c[2], $search), ": nothing found\n";
    return 1;
  }
   map { $_ = $_->file } @artists;
  pipe_add(@artists);

  printf(">> Found %s artist matches for '%s'\n",
    fg('bold', fg($c[6], scalar(@artists))),
    fg('bold', fg($c[5], $search)),
  );
}

sub search_title  {
  my $search = shift;
  my @songs = $mpd->collection->songs_with_title_partial($search);
  if(!@songs) {
    print ">> ", fg($c[2], $search), ": nothing found\n";
    return 1;
  }
   map { $_ = $_->file } @songs;
  pipe_add(@songs);

  printf(">> Found %s titles matches '%s'\n",
    fg('bold', fg($c[6], scalar(@songs))),
    fg('bold', fg($c[5], $search)),
  );
}

sub current {
  if(playlist_is_empty()) {
    print STDERR "Playlist is empty - nothing is playing\n";
    exit(1);
  }
  my $cu = $mpd->current;
  my(
    $artist,
    $song,
    $album,
    $bitrate,
    $genre,
    $pos,
  ) = (
    $cu->artist           // 'undef',
    $cu->title            // 'undef',
    $cu->album            // 'undef',
    $mpd->status->bitrate // 0,
    $cu->genre            // 'No genre',
    $cu->pos + 1,
  );

  my $current = undef;

  if( ($bitrate < 160) and (!$opt_no_color) ) {
    $bitrate = fg($c[5], $bitrate);
  }
  elsif( ($bitrate > 160) and (!$opt_no_color) ) {
    $bitrate = fg($c[11], $bitrate);
  }

  if(!defined($artist) or(!defined($song))) {
    if(terminal_output()) {
      $current = sprintf("%s >> %s %s", fg('bold', $pos), "$basedir/", $cu->file);
    }
    else {
      $current = sprintf(" >> %s %s",
        "$basedir/", $cu->file);
    }
  }
  else {
    if(terminal_output()) {
      $current = sprintf("[%s] >> %s - %s",
        fg('bold', $pos), fg($c[0], $artist), fg($c[0], fg('bold', $song)))
          . sprintf(" from %s ($bitrate kbps) [$genre]", fg($c[0], $album));
    }
    else {
      $current = sprintf(" [%d]>> %s - %s from %s [%s]",
        $pos, $artist, $song, $album, $genre
      );
    }
  }
  return($current);
}

sub pipe_add {
  return if(!@_);
  print "$_\n" for @_;
  $mpd->playlist->add(@_);
}

sub terminal_output {
  if(-t *STDOUT) {
    return 1;
  }
  else {
    @c = (); # make sure no escape sequences escapes through
    return 0;
  }
}

sub sec_and_min {
  my $sec = shift;
  my($s, $m) = localtime($sec);

  return sprintf("%sm % 2ds",
    fg('bold', fg($c[6], $m)),
    fg('bold', fg($c[6], $s)),
  );
}

sub playlist_is_empty {
  if($mpd->playlist->as_items == 0) {
    return 1;
  }
  else {
    return 0;
  }
}

sub invalid_pos {
  my @pos = @_;
  my @playlist = map { $_ = $_->pos } $mpd->playlist->as_items;
  my $fail = 0;

  for(@pos) {
    if($_ ~~ @playlist) {
      # all good
    }
    else {
      $fail++;
    }
  }
  return($fail);
}

sub invalid_re {
  my $re = shift;
  eval { qr/$re/ };
  if($@) {
    return 1;
  }
  else {
    return 0;
  }
}

sub onoff {
  my $what = shift;
  $what = ($what) ? 'Yes' : 'No';
  return($what);
}

sub help {
  print "$APP $VERSION\n";
  pod2usage(verbose => 1);
  exit(0);
}


=pod

=head1 NAME

pimpd - Perl Interface for the Music Player Daemon

=head1 SYNOPSIS

  pimpd [OPTIONS...] (ARG)

=head1 DESCRIPTION

pimpd is an MPD client written in Perl that aims to implement what the
excellent mpc client is lacking (for good reasons), as well as all the
regular functionality one would expect.

=head2 Local playback

If defined in the configuration file, an external player can be used for
playback of music running on another box (the MPD server). This is fully
transparent; when MPD is stopped, so is the external player.

When the --play flag is given, pimpd will connect to MPD and start playback
if neccessary, and at the same time connect to the stream with the specified
external player.

Issues with unreliable network connections/slow disks causing the external
player to exit is eliminated, as well as scenarios where the MPD playlist
might be temporary empty (no playback - external player exits).

=head2 Regular expression based queries

You can search the database and playlist using regular expressions. There are
several other (faster) ways to search as well - by artist, album or title.

Additionally, it's possible to search through all favlists at the same time,
adding the matches to the current playlist. Since pimpd internally keeps an
csv-style database up to date with the favorized tracks, it's enough to search
for artist, album, title, genre and/or file, in any combination.

=head2 Randomizing

  -r will create a new playlist with <num> randomly selected tracks from the
     database added.

  -ra will create a new playlist with <num> randomly selected albums from the
      database added.

  -rt will play a random track from the current playlist.

=head2 Favorites

Favorites are handled in several ways. When the -f flag is used, pimpd will
check for the genre tag of the song and, if existing, save it in the playlist
directory with a year-month_genre-notation.
If there's no genre tag, the $fallback_playlist, specified in the
configuration file, is used.

pimpd will also keep a CSV-style database updated with more additional data on
the song. This have several purposes:

  * other applications might expect regular m3u-style playlists with only a
    defined "file"-field,

  * the database holds additional information on the favorites, which allows for
    more powerful search capabilities, and

  * we can generate nifty stats for loved songs

=head2 Transfering of music

There are several ways of transfering music.

This is especially useful if the MPD server is running elsewhere and you want
to listen to the music locally, or if you want to transfer some music to your
portable music player.

The $ssh_host, $ssh_port and $ssh_user variables in the configuration file
must be defined in the configuration file, and you must be using SSH keys for
this to work over networks.

  -cp  simply copies the currently playing track to the specifed location.

  -cpa copies the full album where the currently playing track is featured.

  -cpl copies all tracks in the specified playlist to the specified location.

=head2 Interactive shell

From the interactive shell one can access almost all functionality that's
available through regular option flags.

=head2 Monitor song changes

There are two ways to monitor song changes:

  -m  simply print song changes to stdout.

  -md monitor in daemon mode. This is useful for things like OSD notifications,
      integration in dzen2 and so on. Most window managers uses their own sort
      of notification functionality which can also be used.

=head2 Now playing

There are three options that will yeild some info on the current track:

  -i     print all information available.

  -np    print information on the currently playing track only, on a single line.

  -nprt  print information on the currently playing track in realtime mode.

=head2 Colors

pimpd does support colorschemes, which are defined and loaded from the
configuration file. 256 colors is supported, as well as no colors at all.

All of this works on local MPD servers as well as remote ones.

=head1 OPTIONS

  -i,     --info          show all info for the currently playing song
  -np,    --current       print basic song info on a single lin
          --np-rt         print updating song info on a single line
  -r,     --random        randomize a new playlist with <num> tracks
  -ra,    --random-album  randomize a new playlist with <num> albums
  -rt,    --random-track  play a random track from the playlist
  -cp,    --copy          copy the current track to specified location
  -cpa,   --cp-album      copy the current album to specified location
  -cpl,   --cp-list       copy playlist <str> to specified location
  -f,     --fav           add the current track to the favorites
  -fs,    --favstats      generate statistics based on previous favorizations
  -l,     --listalbums    list all albums featuring artist
  -lsa,   --listsongs     list all songs on the current album
  -lsp,   --list-pl       list all available playlists
  -pls    --playlist      show the current playlist
  -t,     --track         play track <num> from playlist
  -a,     --add           add playlist <str>. If <str> eq "all", add all
  -aa,    --add-album     add the current album to the playlist
  -m,     --monitor       monitor MPD for song changes (output on STDOUT)
  -md,    --monitor-d     monitor MPD for song changes in daemon mode
  -k,     --kill          kill pimpd when running in daemon mode
  -q,     --queue         queue <num> tracks
  -e,     --external      list all tracks in external playlist
  -sh,    --shell         spawn the interactive pimpd shell
  -spl,   --search-pl     search the playlist for [<pattern>]
  -sdb,   --search-db     search the database for [<pattern>]
  -sar,   --search-artist search the database for [<artist>]
  -sal,   --search-album  search the database for [<album>]
  -set,   --search-title  search the database for [<title>]
  -sap,   --favsearch     search the favlists for artist, album, title, file
  -c,     --clear         clear the playlist before performing any action that
                          generates a new playlist
          --play          start remote/local playback
          --stop          stop remote/local playback
  -no,    --no-color      turn colors off
          --mpd-kill      shut down the MPD server
          --host          remote MPD host
          --port          remote MPD port
          --pass          remote MPD password
          --ssh-host      remote SSH server host
          --ssh-port      remote SSH server port
          --ssh-user      remote SSH server user

  -h,     --help          show the help and exit
          --man           show the manpage and exit

=head1 ENVIRONMENT

The configuration file should be placed in $XDG_CONFIG_HOME/pimpd/pimpd.conf OR
/etc/pimpd.conf

=head1 AUTHOR

  Magnus Woldrich
  CPAN ID: WOLDRICH
  magnus@trapd00r.se
  http://japh.se

=head1 CONTRIBUTORS

Olof Johansson made the original scp routines.

=head1 COPYRIGHT

Copyright (C) 2009, 2010, 2011 B<pimpd>s L</AUTHOR> and L</CONTRIBUTORS> as
listed above.

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

B<pimpd2>  <http://github.com/trapd00r/pimpd2>

=cut
