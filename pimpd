#!/usr/bin/perl
our $APP     = 'pimpd';
our $VERSION = '1.5.0';

use strict;
my $DEBUG = 0;

use Audio::MPD;
use List::Util qw(shuffle);
use Pod::Usage;
use Getopt::Long;
use Data::Dumper;
use File::Copy;
use Carp;
use Pod::Usage;

if(!@ARGV) {
  print "$APP $VERSION\n";
  pod2usage(verbose => 1);
  exit(0);
}

my $config = "$ENV{XDG_CONFIG_HOME}/pimpd/pimpd.conf";
if($DEBUG) {
  require "./pimpd.conf";
}
else {
  eval {require $config;};
  if($@) {
    $config = "/etc/pimpd.conf";
  }
  require($config);
}

# imported variables from the config file
our ($basedir, $playlist_dir, $fallback_playlist, $portable,
     $remote_host, $remote_pass, $remote_user, $history_playlist,
     $opt_color, @c, $daemon_cmd, $remote_port, $pidfile, $ssh_port,
     $ssh_host, $ssh_user, $dzen_font, $dzen_cmd);


our (@opt_queue, $opt_ctrl, @opt_list_external,
     $opt_search_playlist, $opt_search_db, $opt_information, #FIXME
     $opt_randomize, @opt_add_playlist, $opt_playlist,
     $opt_favlist, $opt_play_from_list, $opt_monitoring, $opt_list_albums,
     $opt_current, $opt_search_album, $opt_search_artist,
     $opt_search_title, $opt_monitor_d,
     );

my $e = "\e[38;5";


my $mpd;
if(defined($remote_host)) {
  $mpd = Audio::MPD->new(
    host      => $remote_host,
    port      => $remote_port,
    pass      => $remote_pass,
  );
}
else {
  $mpd = Audio::MPD->new;
}

our($opt_run_cp);
# In case we want to specify another host...
our($opt_remote_host, $opt_remote_port, $opt_remote_pass);
GetOptions(
  'information'        => \$opt_information,
  'np'                 => \$opt_current,
  'randomize:i'        => \$opt_randomize,
  'cp|copy'            => \$opt_run_cp,
  'favorite'           => \$opt_favlist,
  'l|listalbums'       => \$opt_list_albums,
  'p|playlist'         => \$opt_playlist,
  'track|play'         => \$opt_play_from_list,
  'add=s{1,}'          => \@opt_add_playlist,
  'lp|lsp|list-pl'     => sub
  {
    print "$_\n" for sort($mpd->collection->all_playlists);
    exit(0);
  },
  'm|monitor'          => \$opt_monitoring,
  'md|monitord'        => \$opt_monitor_d,
  'queue=i{1,}'        => \@opt_queue,
  'ctrl'               => \$opt_ctrl,
  'external=s{1,}'     => \@opt_list_external,
  'spl|search-pl=s'    => \$opt_search_playlist,
  'sdb|search-db=s'    => \$opt_search_db,
  'sal|search-album=s' => \$opt_search_album,
  'sar|search-artist=s'=> \$opt_search_artist,
  'set|search-title=s' => \$opt_search_title,
  'no-color|nocolor'   => \$opt_color,
  'host:s'             => \$opt_remote_host,
  'port:s'             => \$opt_remote_port,
  'pass:s'             => \$opt_remote_pass,
  'ssh_host'           => \$ssh_host,
  'ssh_port'           => \$ssh_port,

  'kill'               => \&killkid,
  'debug'              => \$DEBUG,
  'h|help'             => \&help,
);

# ... we need to recreate the MPD object
if($opt_remote_host) {
  $opt_remote_port = ($opt_remote_port) ? ($opt_remote_port) : ($remote_port);
  $opt_remote_pass = ($opt_remote_pass) ? ($opt_remote_pass) : ($remote_pass);
  $mpd = Audio::MPD->new(
    host  => $opt_remote_host,
    port  => $opt_remote_port,
    pass  => $opt_remote_pass,
  );
}

if($opt_color) {
  @c = (); # when piped to non-shell apps, \033[0m will look ugly
}

# We need to create the MPD object and parse options first. Now we have done
# that.

cp() if($opt_run_cp);

do {
  my $i = 0;
  for(@c) {
    printf("$c[$i]\$c[$i]\e[0m\n");
    $i++;
  }
} if($DEBUG);

sub listlen_empty_msg {
  printf("%s\n
    OPTIONS:
        rand n    randomize a new playlist with n tracks
        add  s    add playlist s
        sdb  p    search the database for pattern
        sar  p    search for artists matching pattern
        sal  p    search for albums matching pattern
        set  p    search for titles matching pattern

        ", shift,
      );
}

if($mpd->status->playlistlength < 1) {

  do {
    listlen_empty_msg('Your playlist looks empty. Lets add some music');
    print "pimpd\e[38;5;148m>\e[0m";

    while(chomp(my $action = <STDIN>)) {
      if($action =~ /^sdb\s+(.+)/) {
        search_db($1);
        exit(0);
      }

      elsif($action =~ /^rand\s+(.+)/) {
        randomize($1);
        $mpd->play();
        exit(0);
      }

      elsif($action =~ /add\s+(.+)/) {
        my $list = $1;
        add_playlist(split(/\s/, $list));
        exit(0);
      }

      elsif($action =~ /set\s+(.+)/) {
        search_title($1);
        $mpd->play->();
        exit(0);
      }

      elsif($action =~ /sar\s+(.+)/) {
        search_artist($1);
        $mpd->play;
        exit(0);
      }

      elsif($action =~ /sal\s+(.+)/) {
        search_album($1);
        $mpd->play;
        exit(0);
      }

      else {
        listlen_empty_msg("$action: not valid!");
      }
    }
  } unless($opt_randomize
      or $opt_search_db
      or $opt_search_album
      or $opt_search_artist
      or $opt_search_title
      or @opt_add_playlist
  );
}

print current(), "\n"                   if $opt_current;
information()                           if $opt_information;
playlist()                              if $opt_playlist;
favlist()                               if $opt_favlist;
list_albums()                           if $opt_list_albums;
play_from_list()                        if $opt_play_from_list;
monitoring()                            if $opt_monitoring;

if($opt_monitor_d) {
  if(!defined($daemon_cmd)) {
    print STDERR "No daemon command specified in $config\n" and exit(1);
  }
  if(-e $pidfile) {
    print STDERR "pimpd is already running\n" and exit(1);
  }
  else {
    monitoring();
  }
}
randomize($opt_randomize)               if $opt_randomize;
add_playlist(@opt_add_playlist)         if @opt_add_playlist;
queue(@opt_queue)                       if @opt_queue;
ctrl()                                  if $opt_ctrl;
list_external(@opt_list_external)       if @opt_list_external;
search_playlist($opt_search_playlist)   if $opt_search_playlist;

search_db($opt_search_db)               if $opt_search_db;
search_album($opt_search_album)         if $opt_search_album;
search_artist($opt_search_artist)       if $opt_search_artist;
search_title($opt_search_title)         if $opt_search_title;

sub onoff {
  my $what = shift;
  $what = ($what) ? 'Yes' : 'No';
  return($what);
}

sub information {
  my %current = ('artist'     =>  $mpd->current->artist,
                 'album'      =>  $mpd->current->album,
                 'title'      =>  $mpd->current->title,
                 'genre'      =>  $mpd->current->genre,
                 'file'       =>  $mpd->current->file,
                 'date'       =>  $mpd->current->date,
                 'time'       =>  $mpd->status->time->sofar.'/'.
                                  $mpd->status->time->total,
                 'bitrate'    =>  $mpd->status->bitrate,
                 'audio'      =>  $mpd->status->audio,
                 );
  my %status  = ('repeat'     =>  $mpd->status->repeat,
                 'shuffle'    =>  $mpd->status->random,
                 'xfade'      =>  $mpd->status->xfade,
                 'volume'     =>  $mpd->status->volume,
                 'state'      =>  $mpd->status->state,
                 'list'       =>  $mpd->status->playlist,
                 );
  my %stats   = ('song'       =>  $mpd->status->song,
                 'length'     =>  $mpd->status->playlistlength,
                 'songs'      =>  $mpd->stats->songs,
                 'albums'     =>  $mpd->stats->albums,
                 'artists'    =>  $mpd->stats->artists,
                 );

  $current{'bitrate'} = ($current{'bitrate'} < 192)
    ? ("$e;160m$current{'bitrate'}\e[0m")
    : ("$e;70m$current{'bitrate'}\e[0m")
    ;

  for(keys(%current)) {
    $current{$_} = "$e;240mNot Available$e;0m" if(!defined($current{$_}));
  }

  $status{state} = 'Playing' if($status{state} eq 'play');
  $status{state} = 'Paused'  if($status{state} eq 'pause');
  $status{state} = 'Stopped' if($status{state} eq 'stop');

  (undef,undef,undef,undef,undef, my $crnt_year) = localtime(time);
  $crnt_year += 1900;

  $current{date} = "$e;38m\e[1m$current{date}\e[0m" if($current{date} eq $crnt_year);

  $status{repeat}  = onoff($status{repeat});
  $status{shuffle} = onoff($status{repeat});

  if($status{volume} < 0) {
    $status{volume} = 'N/A (Software Mixer)';
  }

  printf("$e;251m\e[1mS\e[0m%10s$c[0]\e[1m %.66s\e[0m \n",
    'Artist:', $current{artist});

  printf("$e;250mO\e[0m%10s$c[1] %.66s\e[0m \n",
    'Album:' , $current{album});

  printf("$e;249mN\e[0m%10s$c[8]\e[1m %.66s \n",
    'Song:'  , $current{title});

  printf("$e;248mG\e[0m%10s %.66s \n",
    'Genre:' , $current{genre});

  printf(" %10s$c[9] \e[1m%.66s\e[0m \n",
    'File:'  , $current{file});

  printf("$e;247m\e[1mI\e[0m%10s %.66s \n",
    'Year:'  , $current{date});

  printf("$e;246mN\e[0m%10s %.66s \n",
    'Time:'  , $current{time});

  printf("$e;245mF\e[0m%10s %.66s \n",
    'Bitrate:'  , $current{bitrate});

  printf("$e;244mO\e[0m%10s %.66s \n",
    'Audio:' , $current{audio});

  print "$c[13]\e[1m";
  print '-' x 25, "\e[0m\n";

  printf("$e;243m\e[1mS\e[0m%10s %.66s \n",
    'Repeat:', $status{repeat});

  printf("$e;242mT\e[0m%10s %.66s \n",
    'Shuffle:',$status{shuffle});

  printf("$e;241mA\e[0m%10s %.66s \n", 'Xfade:', $status{xfade});
  printf("$e;240mT\e[0m%10s %.66s \n", 'Volume:', $status{volume});
  printf("$e;239mU\e[0m%10s %.66s \n", 'State:', $status{state});
  printf("$e;238mS\e[0m%10s %.66s \n", 'List V:', $status{list});

  print "$c[13]\e[1m";
  print '-' x 25, "\e[1m\n";

  printf("$e;243m\e[1mS\e[0m%10s %.66s \n", 'Song:', $stats{song});
  printf("$e;236mT\e[0m%10s %.66s \n", 'List:', $stats{length} . ' songs');
  printf("$e;235mA\e[0m%10s %.66s \n", 'Songs:', $stats{songs});
  printf("$e;234mT\e[0m%10s %.66s \n", 'Albums:', $stats{albums});
  printf("$e;234mS\e[0m%10s %.66s \n", 'Artists:', $stats{artists});

  exit(0);
}

sub randomize {
  my $count = shift // 100;
  my @songs = shuffle($mpd->collection->all_pathes);
  #@songs    = shuffle(@songs);
  $mpd->playlist->clear;
  $mpd->playlist->add(@songs[0 .. $count-1]);
  $mpd->random(1);
  $mpd->repeat(1);
  $mpd->play;
  my $message = "Added $count random songs:\n\n";
  playlist($message);
  exit 0;
}

sub playlist {
  my $header = shift;
  $header = "Playlist:\n" if($header eq 'show');

  my @playlist = $mpd->playlist->as_items;
  my $i        = 0; # so we can count from 1

  print $header;
  printf("%29s %6s\n", 'ARTIST', 'SONG');
  for my $song(@playlist) {
    my $title  = $song->title  // 'undef';
    my $album  = $song->album  // 'undef';
    my $artist = $song->artist // 'undef';

# titlecase
    $title  =~ s/(\w+)/\u\L$1/g;
    $album  =~ s/(\w+)/\u\L$1/g;
    $artist =~ s/(\w+)/\u\L$1/g;
    $i++;

    my $bold = "\e[0m$c[9]";
    if($i % 2 == 0) {
      $bold = "\e[1m$c[13]";
    }
    printf("$bold% 3d\e[0m $bold$c[8]%25.25s$c[8]▕$bold$c[14]|$c[8]▏$bold$c[6]%-47.47s\e[0m\n",
      $i, $artist, $title
    );
  }
  print "\n" . current('show'), "\n";
  exit 0;
}

sub add_playlist {
  if(@_) {
    my @playlists = @_;
    $mpd->playlist->clear;

    for(@playlists) {
      $mpd->playlist->load($_);
    }

    print ">> Adding...\n";
    print "> $_\n" for(@playlists);
    $mpd->play;
    exit(0);
  }
}

sub list_external {
  my @playlists = @_;

  for my $playlist(@playlists) {
    my $full_path = "$playlist_dir/$playlist\.m3u";
    if(defined($remote_host)) {
      # $filepath =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
      open(
        my $fh,
        "ssh -p $ssh_port $ssh_user\@$ssh_host \"/bin/cat $full_path\"|"
      ) or die("$ssh_host:$ssh_port: $!");

      while(<$fh>) {
        print "$c[6]$playlist\e[0m: \e[1m$_\e[0m";
      }
    }
    else {
      open(my $fh, '<', $full_path) or die("Can not open $full_path: $!");
      while(<$fh>) {
        print "$c[4]$playlist\e[0m: \e[1m$_\e[0m";
      }
    }
  }
  exit(0);
}

sub scp {
  my($host, $port, $src, $dest) = @_;

  $src  =~ s/([ '"&;|])/\\$1/g;
  $dest =~ s/([ '"&;|])/\\$1/g;
  system('scp', "-P $port", "$host:$src", $dest) == 0 or croak("scp: $!");
  return(0);
}

sub cp {
  my $dir = $portable;
  chomp(my $file = $mpd->current->file);

  # escape evil chars the shell will munch
  $file =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;

  if(defined($remote_host)) {
    return scp($ssh_host, $ssh_port, "$basedir/$file", $dir)
  }

  if(copy("$basedir/$file", $dir)) {
    print "$file => $dir\n";
  }
  else {
    print STDERR "cp: $!\n";
  }
  exit(0);
}

sub favlist {
  my $playlist = $ARGV[0] // lc($mpd->current->genre);
  if(!defined($playlist) or $playlist eq '') {
    $playlist = $fallback_playlist;
  }
  my $filepath = $mpd->current->file;
  my $fullpath = "$playlist_dir/$playlist";

  if(defined($remote_host)) {
    $filepath =~ s/([;<>\*\|`&\$!#\(\)\[\]\{\}:'"])/\\$1/g;
    system("ssh", "-p $ssh_port", "$ssh_user\@$ssh_host",
      "printf \"%s\n\" $filepath >> $fullpath.m3u") == 0 or croak($!);

    printf("$c[1]%s\e[0m\e[1m >> $ssh_host:$c[3]%s\e[0m\n",
      $filepath, "$fullpath.m3u");
    exit(0);
  }
  open(my $fh, '>>', "$fullpath.m3u")
    or croak("Could not open $fullpath.m3u: $!");
  print $fh "$filepath\n";
  close($fh);

  my $history_path = "$playlist_dir/$history_playlist";

  open(my $fh, '>>', "$history_path.m3u")
    or croak("Could not open $history_path.m3u: $!");
  print $fh "$filepath\n";
  close($fh);

  print $c[1].$filepath,$c[9].' >> ',$c[3]."$fullpath\.m3u",$c[0], "\n";

  exit(0);
}

sub list_albums {
  my $artist = $ARGV[0] // $mpd->current->artist;
  my @albums = sort($mpd->collection->albums_by_artist($artist));

  for(sort(@albums)) {
    print "$_\n";
  }
  printf("\n$c[0]\e[1m%s\e[0m is featured on \e[1m%d\e[0m albums\n",
    $artist, scalar(@albums),
  );
}

sub play_from_list {
  my $choice = $ARGV[0];
  if(!$choice) {
    print STDERR "What should we play?\n";
    exit(1);
  }
  if($choice !~ /^\d+$/) {
    print STDERR "Integers only, please.\n";
    exit(1);
  }
  if($choice > $mpd->status->playlistlength) {
    print STDERR "There are \e[1m" . $mpd->status->playlistlength
      . "\e[0m songs in the playlist. Pick one of them!\n";
    exit(1);
  }
  $mpd->play($choice-1);
  print current();
  exit(0);
}

sub daemonize {
  use POSIX 'setsid';
  my $PID = fork();
  exit(0) if($PID); #parent
  exit(1) if(!defined($PID)); # out of resources

  setsid();
  $PID = fork();
  exit(1) if(!defined($PID));

  if($PID) { # parent
    waitpid($PID, 0);
    unlink($pidfile); # remove the lock when child have died
    exit(0);
  }
  elsif($PID == 0) { # child
    open(my $fh, '>', $pidfile) or die("Cant open $pidfile: $!");
    print $fh $$;
    close($fh);
    open(STDOUT, '>', '/dev/null');
    open(STDERR, '>', '/dev/null');
    open(STDIN,  '<', '/dev/null');
  }
}

sub killkid {
  open(my $fh, '<', $pidfile) or print "pimpd is not running\n" and exit(1);
  my $target = <$fh>;
  close($fh);

  if(kill(9, $target)) {
    print "pimpd with PID $target terminated\n";
  }
  else {
    print "Could not kill $target: $!";
  }
  exit(0);
}

sub monitoring {
  my $np = "";
  unless($DEBUG) {
    daemonize if($opt_monitor_d);
  }

  while(1) {
    my $current = $mpd->current;
    return(1) if(!defined($current)); # not running?
    my $output;
    if($opt_monitor_d) {
      my $artist = $mpd->current->artist // 'undef';
      my $album  = $mpd->current->album  // 'undef';
      my $title  = $mpd->current->title  // 'undef';
      my $genre  = $mpd->current->genre  // 'undef';
      my $year   = $mpd->current->date   // 0;

      if($daemon_cmd eq 'dzen') {
        $output = sprintf(
          "^fg(#4af617)%s ^fg(#999999)by^fg() ^fg(#fa4b04)%s^fg(#999999) (^fg(#fa0443) %s^fg(#999999) ) ^fg(#999999)from ^fg(#1c79ed)%s^fg()",
          $title, $artist, $album, $year);
      }
      else {
        $output = sprintf("%s (%s) %s | %s", $artist, $album, $title, $genre);
      }
    }

    if("$np" ne "$current") {
      $np = $current;

      if($opt_monitor_d) {
        if($daemon_cmd eq 'dzen') {
          system("echo \"$output\" | $dzen_cmd");
        }
        else {
          system("$daemon_cmd \"$output\"");
        }
      }
      else {
        my @date = localtime(time);
        my @rc = shuffle(@c);
        my $file = $mpd->current->file;
        printf("%02s:%02s:%02s | $rc[0]%.68s$c[9]\n",
               $date[2], $date[1], $date[0], $file);
           }
         }
         sleep 2;
       }
     }
sub queue {
  my @to_play = @_;
  if(scalar(@to_play < 1)) {
    print STDERR "The queue function requires at least one song \n";
    exit(1)
  }

  # The playlist numbering starts with 1
  # The internal numbering starts with 0
  @to_play = map { $_-- };

  my @track_in_list = $mpd->playlist->as_items;
  my $argc = 0;
  print for @to_play;

  print ">> Starting queue...\n";
  while(scalar(@to_play) > $argc) {

    $mpd->play($to_play[$argc]);

    my $time = $mpd->status->time->seconds_total;
    $argc++;

    my $next_in_list = $to_play[$argc];
    print current() . "\n";

    printf("$c[13]>>> %s - %s - %s \e[0m\n",
      $track_in_list[$next_in_list]->artist,
      $track_in_list[$next_in_list]->album,
      $track_in_list[$next_in_list]->title,
    ) if(scalar(@to_play) != $argc);

    if(scalar(@to_play) == 1) {
      exit(0);
    }
    sleep($time);
  }
  print ">> Queue finished.\n";
}

sub ctrl {
  my $option = shift;
  print << 'CMD';
This is the pimpd shell for simple interacting with MPD.

 Available commands are:

 n    next track
 p    previous track
 t    toggle pause/play
 s    shuffle the playlist
np    print currently playing song
ra    toggle random on/off
re    toggle repeat on/off
cl    clear the playlist
cr    remove all tracks in playlist except for the current one

:q     quit

CMD

  my $opts = {
    'n'  =>  sub {$mpd->next; print &current, "\n"},
    'p'  =>  sub {$mpd->prev; print &current, "\n"},
    't'  =>  sub {$mpd->pause; print $mpd->status->state, "\n"},
    's'  =>  sub {$mpd->playlist->shuffle; print $mpd->status->playlist, "\n"},
    'np' =>  sub {print &current, "\n"},
    'ra' =>  sub {$mpd->random; print $mpd->status->random, "\n"},
    're' =>  sub {$mpd->repeat; print $mpd->status->repeat, "\n"},
    'cl' =>  sub {$mpd->playlist->clear},
    'cr' =>  sub {$mpd->playlist->crop},
    ':q' =>  sub {exit 0},
  };

  print '-' x 40, "\n";
  while(1) {
    print "pimpd\e[1m>\e[0m ";
    chomp(my $choice = <STDIN>);
    defined($opts->{$choice}) && $opts->{$choice}->();
  }
}
sub search_playlist {
  my $search   = shift;
  my @playlist = $mpd->playlist->as_items;
  my @found;
  
  foreach my $song(@playlist) {
    if($song =~ /$search/i) {
      print '> ', $song->title, "\n";
      push(@found, $song->pos);
    }
  }
  &queue(@found);
}

sub search_db {
  my $search = shift; 
  my @collection = $mpd->collection->all_pathes;

  foreach my $song(@collection) {
    if($song =~ /$search/i) {
      printf("> %.77s\n", $song); 
      $mpd->playlist->add($song);
    }
  }
  $mpd->play;
  exit 0;
}

sub search_album {
  my $search = shift;
  my @tracks = $mpd->collection->songs_from_album_partial($search); 
  if(!@tracks) {
    print ">> $c[2]$search$c[9]: no tracks found\n";
    exit 1;
  }
  my @files;
  foreach my $track(@tracks) {
    push(@files, $track->file);
  }
  pipe_add(@files);
  print ">> ", "\e[1m$c[6]", scalar(@files), "\e[0m",
        " tracks found matching \e[1m$c[10]$search\e[0m$c[9] in the \e[1malbum\e[0m tag\n";
}

sub search_artist {
  my $search = shift;
  my @artists = $mpd->collection->songs_by_artist_partial($search);
  if(!@artists) {
    print ">> $c[2]$search$c[9]: nothing found\n";
    exit 1;
  }
  my @files;
  foreach my $artist(@artists) {
    push(@files, $artist->file);
  }
  &pipe_add(@files);
  print ">> ", "\e[1m$c[6]\e[0m", scalar(@artists), "\e[0m",
        " tracks found by artist(s) matching \e[1m$c[10]$search\e[0m$c[9]\n";
}

sub search_title  {
  my $search = shift;
  my @songs = $mpd->collection->songs_with_title_partial($search);
  if(!@songs) {
    print ">> $c[2]$search$c[9]: nothing found\n";
    exit 1;
  }
  my @files;
  foreach my $song(@songs) {
    push(@files, $song->file);
  }
  &pipe_add(@files);
  print ">> ", "\e[1m$c[6]", scalar(@songs), "\e[0m",
        " titles found matching $c[10]$search $c[9]\n";
}

sub pipe_add {
  my @files = (@_);
  foreach my $file(@files) {
    print $file, "\n";
    $mpd->playlist->add($file);
  }
} 
  
sub current {
  my $cu = $mpd->current;
  my($artist,$song,$album,$bitrate,$genre) = ($cu->artist,$cu->title,$cu->album,
    $mpd->status->bitrate, $cu->genre);

  my $current = undef;

  if(!defined($artist) or(!defined($song))) {
    if(-t *STDOUT) { #output to terminal?
      $current = sprintf("$c[1] >>$c[9] %s\033[1m%s\033[0m",
        "$basedir/", $cu->file);
    }
    else {
      $current = sprintf(" >> %s %s",
        "$basedir/", $cu->file);
    }
  }
  else {
    if(-t *STDOUT) { # FIXME make this a to-be-called function
      $current = sprintf("$c[3] >>$c[9] %s - \033[1m%s\033[0m ",
        $artist, $song) .
          sprintf("from \033[1m%s\033[0m ($bitrate kbps) [$genre]", $album);
    }
    else {
      $current = sprintf(" >> %s - %s from %s (%s kbps) [%s]",
        $artist, $song, $album, $bitrate, $genre
      );
    }
  }
  return($current);
}

sub help {
  print "$APP $VERSION\n";
  pod2usage(verbose => 1);
  exit(0);
}


=pod

=head1 NAME

  pimpd - Perl Interface for the Music Player Daemon

=head1 SYNOPSIS

  pimpd [OPTIONS...] (ARG)

=head1 DESCRIPTION

  pimpd is an MPD client written in Perl that implements regular expression
  based database/playlist queries, randomizing of playlists, queue
  functionality, interactive shell, monitoring (to STDOUT and daemonized),
  ability to copy the currently playing song to your portable player, favorizing
  of specific tracks, loads of information spamming, support for colorschemes
  and 256 colors, and quite a bit more. See OPTIONS for a full specification.

  All of this works on local MPD servers as well as remote ones.

=head1 OPTIONS

  -i,     --info          print all information available
  -np,    --current       print now playing information on single line
  -r,     --random        randomize a new playlist with n tracks
  -cp,    --copy          copy the current track to specified location (C)
  -f,     --fav           favorize the current track. If no name for the playlist
                          is specified, the GENRE id3-tag is used
  -l,     --listalbums    list all albums by artist
  -lsp,   --list-pl       list all available playlists
  -p,     --playlist      show the current playlist
  -t,     --track         play track number n from playlist
  -a,     --add           add playlist and play it
  -m,     --monitor       monitor MPD for song changes (output on STDOUT)
  -md,    --monitor-d     monitor MPD for song changes in daemon mode. Where the
                          output should go is specified in the configuration file.
  -q,     --queue         queue specified tracks
  -e,     --external      list all tracks in external playlist
          --ctrl          spawn the interactive pimpd shell
  -spl,   --search-pl     search the current playlist for pattern and queue the
                          results
  -sdb,   --search-db     search the database for pattern and add the results to
                          the current playlist
  -sar,   --search-artist search the database for artist and add the results to 
                          the current playlist
  -sal,   --search-album  search the database for album and add the result to
                          the current playlist
  -set,   --search-title  search the database for title and add the results to
                          the current playlist
  -no,    --no-color      turn colors off (C)
          --host          remote MPD host (C)
          --port          remote MPD port (C)
          --pass          remote MPD password (C)
          --ssh-host      remote SSH server host (used for -cp) (C)
          --ssh-port      remote SSH server port (used for -cp) (C)

  -h,     --help          show the help and exit
          --man           show the manpage and exit

=head1 ENVIRONMENT

The configuration file should be placed in $XDG_CONFIG_HOME/pimpd/pimpd.conf OR
/etc/pimpd.conf

=head1 AUTHOR

Written by Magnus Woldrich

=head1 REPORTING BUGS

Report bugs and feature requests at the issue tracker
<http://github.com/trapd00r/pimpd/issues>

Report your love and send virtual hugs to <trapd00r@trapd00r.se>
If you need to send more then virtual hugs - contact me by the mail first.

=head1 COPYRIGHT

Copyright (C) 2009, 2010 Magnus Woldrich

=head1 SEE ALSO

B<rmcd>  <http://github.com/trapd00r/rmcd>

=cut
